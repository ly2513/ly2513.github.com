[{"title":"每天掌握一个Linux命令(20): find命令之exec","date":"2017-03-05T11:19:53.000Z","path":"2017/03/05/每天掌握一个Linux命令-20-find命令之exec/","text":"find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候exec的作用就显现出来了。 exec解释： -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。 {} 花括号代表前面find查找出来的文件名。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 例一：ls -l命令放在find命令的-exec选项中命令：find . -type f -exec ls -l {} \\; 输出： 12345678910111213[root@localhost test]# find . -type f -exec ls -l &#123;&#125; \\;-rw-r--r-- 1 root root 127 10-28 16:51 ./log2014.log-rw-r--r-- 1 root root 0 10-28 14:47 ./test4/log3-2.log-rw-r--r-- 1 root root 0 10-28 14:47 ./test4/log3-3.log-rw-r--r-- 1 root root 0 10-28 14:47 ./test4/log3-1.log-rw-r--r-- 1 root root 33 10-28 16:54 ./log2013.log-rw-r--r-- 1 root root 302108 11-03 06:19 ./log2012.log-rw-r--r-- 1 root root 25 10-28 17:02 ./log.log-rw-r--r-- 1 root root 37 10-28 17:07 ./log.txt-rw-r--r-- 1 root root 0 10-28 14:47 ./test3/log3-2.log-rw-r--r-- 1 root root 0 10-28 14:47 ./test3/log3-3.log-rw-r--r-- 1 root root 0 10-28 14:47 ./test3/log3-1.log[root@localhost test]# 说明： 上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 例二：在目录中查找更改时间在n日以前的文件并删除它们命令：find . -type f -mtime +14 -exec rm {} \\; 输出： 1234567891011121314151617181920[root@localhost test]# ll总计 328-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log-rw-r--r-- 1 root root 33 10-28 16:54 log2013.log-rw-r--r-- 1 root root 127 10-28 16:51 log2014.loglrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.log-rw-r--r-- 1 root root 25 10-28 17:02 log.log-rw-r--r-- 1 root root 37 10-28 17:07 log.txtdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxrwxrwx 2 root root 4096 10-28 14:47 test4[root@localhost test]# find . -type f -mtime +14 -exec rm &#123;&#125; \\;[root@localhost test]# ll总计 312-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.loglrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 11-12 19:32 test3drwxrwxrwx 2 root root 4096 11-12 19:32 test4[root@localhost test]# 说明： 在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。 例三：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示命令：find . -name “*.log” -mtime +5 -ok rm {} \\; 输出： 1234567891011121314151617[root@localhost test]# ll总计 312-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.loglrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 11-12 19:32 test3drwxrwxrwx 2 root root 4096 11-12 19:32 test4[root@localhost test]# find . -name &quot;*.log&quot; -mtime +5 -ok rm &#123;&#125; \\;&lt; rm ... ./log_link.log &gt; ? y&lt; rm ... ./log2012.log &gt; ? n[root@localhost test]# ll总计 312-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 11-12 19:32 test3drwxrwxrwx 2 root root 4096 11-12 19:32 test4[root@localhost test]# 说明： 在上面的例子中， find命令在当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除。 例四：-exec中使用grep命令命令：find /etc -name “passwd*” -exec grep “root” {} \\; 输出： 1234[root@localhost test]# find /etc -name &quot;passwd*&quot; -exec grep &quot;root&quot; &#123;&#125; \\;root:x:0:0:root:/root:/bin/bashroot:x:0:0:root:/root:/bin/bash[root@localhost test]# 说明： 任何形式的命令都可以在-exec选项中使用。 在上面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例五：查找文件移动到指定目录命令：find . -name “*.log” -exec mv {} .. \\; 输出： 12345678910111213141516171819202122[root@localhost test]# ll总计 12drwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxr-x 2 root root 4096 11-12 22:49 test3drwxrwxr-x 2 root root 4096 11-12 19:32 test4[root@localhost test]# cd test3/[root@localhost test3]# ll总计 304-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log-rw-r--r-- 1 root root 61 11-12 22:44 log2013.log-rw-r--r-- 1 root root 0 11-12 22:25 log2014.log[root@localhost test3]# find . -name &quot;*.log&quot; -exec mv &#123;&#125; .. \\;[root@localhost test3]# ll总计 0[root@localhost test3]# cd ..[root@localhost test]# ll总计 316-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log-rw-r--r-- 1 root root 61 11-12 22:44 log2013.log-rw-r--r-- 1 root root 0 11-12 22:25 log2014.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxr-x 2 root root 4096 11-12 22:50 test3drwxrwxr-x 2 root root 4096 11-12 19:32 test4[root@localhost test]# 例六：用exec选项执行cp命令命令：find . -name “*.log” -exec cp {} test3 \\; 输出： 123456789101112131415161718192021[root@localhost test3]# ll总计 0[root@localhost test3]# cd ..[root@localhost test]# ll总计 316-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log-rw-r--r-- 1 root root 61 11-12 22:44 log2013.log-rw-r--r-- 1 root root 0 11-12 22:25 log2014.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxr-x 2 root root 4096 11-12 22:50 test3drwxrwxr-x 2 root root 4096 11-12 19:32 test4[root@localhost test]# find . -name &quot;*.log&quot; -exec cp &#123;&#125; test3 \\;cp: “./test3/log2014.log” 及 “test3/log2014.log” 为同一文件cp: “./test3/log2013.log” 及 “test3/log2013.log” 为同一文件cp: “./test3/log2012.log” 及 “test3/log2012.log” 为同一文件[root@localhost test]# cd test3[root@localhost test3]# ll总计 304-rw-r--r-- 1 root root 302108 11-12 22:54 log2012.log-rw-r--r-- 1 root root 61 11-12 22:54 log2013.log-rw-r--r-- 1 root root 0 11-12 22:54 log2014.log[root@localhost test3]#","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(19): find命令概览","date":"2017-03-05T11:09:31.000Z","path":"2017/03/05/每天掌握一个Linux命令-19-find命令概览/","text":"Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 1.命令格式 find pathname -options [-print -exec -ok …] 2.命令功能 用于在文件树种查找文件，并作出相应的处理 3.命令参数 pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } ;，注意{ }和；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 4.命令选项 -name 按照文件名查找文件。-perm 按照文件权限来查找文件。-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 -user 按照文件属主来查找文件。-group 按照文件所属的组来查找文件。-mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。 -type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。 -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。 -mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。 另外,下面三个的区别: -amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 5.使用实例 例一：查找指定时间内修改过的文件命令：find -atime -2 输出： 123456[root@localhost ~]# find -atime -2../logs/monitor./.bashrc./.bash_profile./.bash_history 说明：超找48小时内修改过的文件 例二：根据关键字查找命令：find . -name “*.log” 输出： 12345678910111213141516171819[root@localhost test]# find . -name &quot;*.log&quot;./log_link.log./log2014.log./test4/log3-2.log./test4/log3-3.log./test4/log3-1.log./log2013.log./log2012.log./log.log./test5/log5-2.log./test5/log5-3.log./test5/log.log./test5/log5-1.log./test5/test3/log3-2.log./test5/test3/log3-3.log./test5/test3/log3-1.log./test3/log3-2.log./test3/log3-3.log./test3/log3-1.log 说明：在当前目录查找 以.log结尾的文件。 “. “代表当前目录 例三：按照目录或文件的权限来查找文件命令：find /opt/soft/test/ -perm 777 输出： 12345[root@localhost test]# find /opt/soft/test/ -perm 777/opt/soft/test/log_link.log/opt/soft/test/test4/opt/soft/test/test5/test3/opt/soft/test/test3 说明： 查找/opt/soft/test/目录下 权限为 777的文件 例四：按类型查找命令：find . -type f -name “*.log” 输出： 12345678910111213141516171819[root@localhost test]# find . -type f -name &quot;*.log&quot;./log2014.log./test4/log3-2.log./test4/log3-3.log./test4/log3-1.log./log2013.log./log2012.log./log.log./test5/log5-2.log./test5/log5-3.log./test5/log.log./test5/log5-1.log./test5/test3/log3-2.log./test5/test3/log3-3.log./test5/test3/log3-1.log./test3/log3-2.log./test3/log3-3.log./test3/log3-1.log[root@localhost test]# 说明： 查找当目录，以.log结尾的普通文件 例五：查找当前所有目录并排序命令：find . -type d | sort 输出： 123456789101112131415[root@localhost test]# find . -type d | sort../scf./scf/bin./scf/doc./scf/lib./scf/service./scf/service/deploy./scf/service/deploy/info./scf/service/deploy/product./test3./test4./test5./test5/test3[root@localhost test]# 例六：按大小查找文件命令：find . -size +1000c -print 输出： 12345678910111213141516[root@localhost test]# find . -size +1000c -print../test4./scf./scf/lib./scf/service./scf/service/deploy./scf/service/deploy/product./scf/service/deploy/info./scf/doc./scf/bin./log2012.log./test5./test5/test3./test3[root@localhost test]# 说明： 查找当前目录大于1K的文件","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(18): locate命令","date":"2017-03-05T10:57:28.000Z","path":"2017/03/05/每天掌握一个Linux命令-18-locate命令/","text":"locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 1.命令格式 Locate [选择参数] [样式] 2.命令功能 locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab) locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。 locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 3.命令参数 -e 将排除在寻找的范围之外。-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料。-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 4.使用实例 例一:查找和pwd相关的所有文件命令：locate pwd 输出： 12345678910111213141516peida-VirtualBox ~ # locate pwd/bin/pwd/etc/.pwd.lock/sbin/unix_chkpwd/usr/bin/pwdx/usr/include/pwd.h/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.py/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.pyc/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.py/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.pyc/usr/lib/syslinux/pwd.c32/usr/share/help/C/empathy/irc-join-pwd.page/usr/share/help/ca/empathy/irc-join-pwd.page/usr/share/help/cs/empathy/irc-join-pwd.page/usr/share/help/de/empathy/irc-join-pwd.page/usr/share/help/el/empathy/irc-join-pwd.page 例二： 搜索etc目录下所有以sh开头的文件命令：locate /etc/sh 输出： 12345peida-VirtualBox ~ # locate /etc/sh/etc/shadow/etc/shadow-/etc/shellspeida-VirtualBox ~ # 例三：搜索etc目录下，所有以m开头的文件命令：locate /etc/m 输出： 1234567peida-VirtualBox ~ # locate /etc/m/etc/magic/etc/magic.mime/etc/mailcap/etc/mailcap.order/etc/manpath.config/etc/mate-settings-daemon","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(17): whereis命令","date":"2017-03-05T10:35:34.000Z","path":"2017/03/05/每天掌握一个Linux命令-17-whereis命令/","text":"whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 1.命令格式 whereis [-bmsu] [BMS 目录名 -f ] 文件名 2.命令功能 whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 3.命令参数 -b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 4.使用实例 例一：将和**文件相关的文件都查找出来命令：whereis svn 输出：1234[root@localhost ~]# whereis tomcattomcat:[root@localhost ~]# whereis svnsvn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz 说明： tomcat没安装，找不出来，svn安装找出了很多相关文件 实例2：只将二进制文件 查找出来 命令：whereis -b svn 输出：1234567[root@localhost ~]# whereis -b svnsvn: /usr/bin/svn /usr/local/svn[root@localhost ~]# whereis -m svnsvn: /usr/share/man/man1/svn.1.gz[root@localhost ~]# whereis -s svnsvn:[root@localhost ~]# 说明： whereis -m svn 查出说明文档路径，whereis -s svn 找source源文件。","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(16): which命令","date":"2017-03-01T10:03:29.000Z","path":"2017/03/01/每天掌握一个Linux命令-16-which命令/","text":"我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 1.命令格式 which 可执行文件名称 2.命令功能 which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 3.命令参数 -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p 与-n参数相同，但此处的包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 4.使用实例 例一：查找文件、显示命令路径命令：which lsmod 输出： 12345[root@localhost ~]# which pwd/bin/pwd[root@localhost ~]# which adduser/usr/sbin/adduser[root@localhost ~]# 说明： which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ 例二：用 which 去找出 which命令： which which 输出： 1234[root@localhost ~]# which whichalias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos; /usr/bin/which[root@localhost ~]# 说明： 竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！ 例三：找出 cd 这个命令命令：which cd 说明： cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(15): tail命令","date":"2017-03-01T09:45:31.000Z","path":"2017/03/01/每天掌握一个Linux命令-15-tail命令/","text":"tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 1.命令格式 tail[必要参数][选择参数][文件] 2.命令功能 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 3.命令参数 -f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.-q, –quiet, –silent 从不输出给出文件名的首部-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 4.使用实例 例一：显示文件末尾内容命令：tail -n 5 log2014.log 输出： 123456[root@localhost test]# tail -n 5 log2014.log2014-092014-102014-112014-12==============================[root@localhost test]# 说明： 显示文件最后5行内容 例二：循环查看文件内容命令：tail -f test.log 输出： 123456789101112131415[root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp;[1] 11891[root@localhost ~]# tail -f test.logPING 192.168.120.204 (192.168.120.204) 56(84) bytes of data.64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms[root@localhost ~]# 说明： ping 192.168.120.204 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 例三：从第5行开始显示文件命令：tail -n +5 log2014.log 输出： ```shell[root@localhost test]# cat log2014.log2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-11 2014-12[root@localhost test]# tail -n +5 log2014.log2014-052014-062014-072014-082014-092014-102014-11 2014-12```s","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(14): head命令","date":"2017-03-01T09:31:00.000Z","path":"2017/03/01/每天掌握一个Linux命令-14-head命令/","text":"head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 1.命令格式 head [参数]… [文件]… 2.命令功能 head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 3.命令参数 -q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 4.使用实例 例一：显示文件的前n行命令：head -n 5 log2014.log 输出： 1234567891011121314151617181920[root@localhost test]# cat log2014.log2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-112014-12==============================[root@localhost test]# head -n 5 log2014.log2014-012014-022014-032014-042014-05[root@localhost test]# 例二：显示文件前n个字节命令：head -c 20 log2014.log 输出： 12345[root@localhost test]# head -c 20 log2014.log2014-012014-022014[root@localhost test]# 例三：文件的除了最后n个字节以外的内容命令：head -c -32 log2014.log 输出： 12345678910111213[root@localhost test]# head -c -32 log2014.log2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-112014-12[root@localhost test]# 例四：输出文件除了最后n行的全部内容命令：head -n -6 log2014.log 输出： 12345678[root@localhost test]# head -n -6 log2014.log2014-012014-022014-032014-042014-052014-062014-07[root@localhost test]#","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(13): less命令","date":"2017-03-01T09:14:28.000Z","path":"2017/03/01/每天掌握一个Linux命令-13-less命令/","text":"less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 1.命令格式 less [参数] 文件 2.命令功能 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 3.命令参数 -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 4.使用实例 例一：查看文件命令：less log2013.log 例二：ps查看进程信息并通过less分页显示命令：ps -ef |less 例三：查看命令历史使用记录并通过less分页显示命令：history | less 输出： 12345678910111213141516171819202122232425262728293031323334353637383940 [root@localhost test]# history | less 22 scp -r tomcat6.0.32 root@192.168.120.203:/opt/soft 23 cd .. 24 scp -r web root@192.168.120.203:/opt/ 25 cd soft 26 ls 27 scp -r jdk1.6.0_16/ root@192.168.120.203:/opt/soft 28 clear 29 vim /etc/profile 30 vim /etc/profile 31 cd tomcat6.0.32/bin/ 32 ls 33 ./shutdown.sh 34 ./startup.sh 35 vim startup.sh36 ls 37 echo $JAVA_HOME 38 java 39 ls40 ls 41 clear 42 cd /opt 43 ls 44 cp apache-tomcat-6.0.32.tar.gz soft/ 45 ls 46 rm -f apache-tomcat-6.0.32.tar.gz 47 ls 48 cd soft 49 ls 50 tar -vzf apache-tomcat-6.0.32.tar.gz 51 tar -vzfx apache-tomcat-6.0.32.tar.gz 52 tar -zxvf apache-tomcat-6.0.32.tar.gz 53 ls 54 cd apache-tomcat-6.0.32 55 ls 56 cd .. 57 mv apache-tomcat-6.0.32 tomcat6.0.32 58 ls 59 cd tomcat6.0.32/ 60 ls 例五：浏览多个文件命令：Less log2013.log log2014.log 说明： 输入 ：n后，切换到 log2014.log输入 ：p 后，切换到log2013.log 5.附加备注 全屏导航 ctrl + F - 向前移动一屏 ctrl + B - 向后移动一屏 ctrl + D - 向前移动半屏 ctrl + U - 向后移动半屏 单行导航 j - 向前移动一行 k - 向后移动一行 其它导航 G - 移动到最后一行 g - 移动到第一行 q / ZZ - 退出 less 命令 其它有用的命令 v - 使用配置的编辑器编辑当前文件 h - 显示 less 的帮助文档 &amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航 当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置： ma - 使用 a 标记文本的当前位置 ‘a - 导航到标记 a 处","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(12): more命令","date":"2017-03-01T09:07:54.000Z","path":"2017/03/01/每天掌握一个Linux命令-12-more命令/","text":"more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 1.命令格式 more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ] 2.命令功能 more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 3.命令参数 +n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 4.常用操作命令 Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号V 调用vi编辑器!命令 调用Shell，并执行命令q 退出more 5.命令实例 例一：显示文件中从第3行起的内容命令：more +3 log2012.log 输出： 12345678910111213[root@localhost test]# cat log2012.log2012-012012-022012-032012-04-day12012-04-day22012-04-day3======[root@localhost test]# more +3 log2012.log2012-032012-04-day12012-04-day22012-04-day3======[root@localhost test]# 例二：从文件中查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出命令：more +/day3 log2012.log 输出： 123456789[root@localhost test]# more +/day3 log2012.log...skipping2012-04-day12012-04-day22012-04-day32012-052012-05-day1======[root@localhost test]# 例三：设定每屏显示行数命令：more -5 log2012.log 输出： 123456[root@localhost test]# more -5 log2012.log2012-012012-022012-032012-04-day12012-04-day2 例四：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来命令：ls -l | more -5 输出： 1234567891011[root@localhost test]# ls -l | more -5总计 36-rw-r--r-- 1 root root 308 11-01 16:49 log2012.log-rw-r--r-- 1 root root 33 10-28 16:54 log2013.log-rw-r--r-- 1 root root 127 10-28 16:51 log2014.loglrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.log-rw-r--r-- 1 root root 25 10-28 17:02 log.log-rw-r--r-- 1 root root 37 10-28 17:07 log.txtdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxrwxrwx 2 root root 4096 10-28 14:47 test4 说明： 每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(11): nl命令","date":"2017-03-01T08:59:18.000Z","path":"2017/03/01/每天掌握一个Linux命令-11-nl命令/","text":"nl 命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 1.命令格式 nl [选项]… [文件]… 2.命令参数 -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 -p 在逻辑定界符处不重新开始计算。 3.命令功能 nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 4.使用实例 例一：用 nl 列出 log2012.log 的内容命令：nl log2012.log 输出： 1234[root@localhost test]# nl log2012.log 1 2012-01 2 2012-02 3 ======[root@localhost test]# 说明： 文件中的空白行，nl 不会加上行号 例二：用 nl 列出 log2012.log 的内容，空本行也加上行号命令：nl -b a log2012.log 输出： 123456[root@localhost test]# nl -b a log2012.log 1 2012-01 2 2012-02 3 4 5 ======[root@localhost test]# 例三：让行号前面自动补上0,统一输出格式 , 读取log2014.log内容,行号前面自动补0命令：nl -b a -n rz log2014.log 输出： 1234567891011121314151617181920212223242526272829[root@localhost test]# nl -b a -n rz log2014.log000001 2014-01000002 2014-02000003 2014-03000004 2014-04000005 2014-05000006 2014-06000007 2014-07000008 2014-08000009 2014-09000010 2014-10000011 2014-11000012 2014-12000013 =======[root@localhost test]# nl -b a -n rz -w 3 log2014.log001 2014-01002 2014-02003 2014-03004 2014-04005 2014-05006 2014-06007 2014-07008 2014-08009 2014-09010 2014-10011 2014-11012 2014-12013 ======= 说明： nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"Redis百亿级Key存储方案","date":"2017-02-28T10:42:07.000Z","path":"2017/02/28/Redis百亿级Key存储方案/","text":"需求背景该应用场景为DMP缓存存储需求，DMP需要管理非常多的第三方id数据，其中包括各媒体cookie与自身cookie（以下统称supperid）的mapping关系，还包括了supperid的人口标签、移动端id（主要是idfa和imei）的人口标签，以及一些黑名单id、ip等数据。 在hdfs的帮助下离线存储千亿记录并不困难，然而DMP还需要提供毫秒级的实时查询。由于cookie这种id本身具有不稳定性，所以很多的真实用户的浏览行为会导致大量的新cookie生成，只有及时同步mapping的数据才能命中DMP的人口标签，无法通过预热来获取较高的命中，这就跟缓存存储带来了极大的挑战。 经过实际测试，对于上述数据，常规存储超过五十亿的kv记录就需要1T多的内存，如果需要做高可用多副本那带来的消耗是巨大的，另外kv的长短不齐也会带来很多内存碎片，这就需要超大规模的存储方案来解决上述问题。 存储何种数据人⼝标签主要是cookie、imei、idfa以及其对应的gender（性别）、age（年龄段）、geo（地域）等；mapping关系主要是媒体cookie对supperid的映射。以下是数据存储⽰示例： 1) PC端的ID： 媒体编号-媒体cookie=&gt;supperid supperid =&gt; { age=&gt;年龄段编码，gender=&gt;性别编码，geo=&gt;地理位置编码 } 2) Device端的ID： imei or idfa =&gt; { age=&gt;年龄段编码，gender=&gt;性别编码，geo=&gt;地理位置编码 } 显然PC数据需要存储两种key=&gt;value还有key=&gt;hashmap，⽽而Device数据需要存储⼀一种 key=&gt;hashmap即可。 数据特点短key短value：其中superid为21位数字：比如1605242015141689522；imei为小写md5：比如2d131005dc0f37d362a5d97094103633；idfa为大写带”-”md5：比如：51DFFC83-9541-4411-FA4F-356927E39D04；媒体自身的cookie长短不一；需要为全量数据提供服务，supperid是百亿级、媒体映射是千亿级、移动id是几十亿级；每天有十亿级别的mapping关系产生；对于较大时间窗口内可以预判热数据（有一些存留的稳定cookie）；对于当前mapping数据无法预判热数据，有很多是新生成的cookie； 存在的技术挑战1）长短不一容易造成内存碎片； 2）由于指针大量存在，内存膨胀率比较高，一般在7倍，纯内存存储通病； 3）虽然可以通过cookie的行为预判其热度，但每天新生成的id依然很多（百分比比较敏感，暂不透露）； 4）由于服务要求在公网环境（国内公网延迟60ms以下）下100ms以内，所以原则上当天新更新的mapping和人口标签需要全部in memory，而不会让请求落到后端的冷数据； 5）业务方面，所有数据原则上至少保留35天甚至更久； 6）内存至今也比较昂贵，百亿级Key乃至千亿级存储方案势在必行！ 解决方案5.1 淘汰策略存储吃紧的一个重要原因在于每天会有很多新数据入库，所以及时清理数据尤为重要。主要方法就是发现和保留热数据淘汰冷数据。 网民的量级远远达不到几十亿的规模，id有一定的生命周期，会不断的变化。所以很大程度上我们存储的id实际上是无效的。而查询其实前端的逻辑就是广告曝光，跟人的行为有关，所以一个id在某个时间窗口的（可能是一个campaign，半个月、几个月）访问行为上会有一定的重复性。 数据初始化之前，我们先利用hbase将日志的id聚合去重，划定TTL的范围，一般是35天，这样可以砍掉近35天未出现的id。另外在Redis中设置过期时间是35天，当有访问并命中时，对key进行续命，延长过期时间，未在35天出现的自然淘汰。这样可以针对稳定cookie或id有效，实际证明，续命的方法对idfa和imei比较实用，长期积累可达到非常理想的命中。 5.2 减少膨胀Hash表空间大小和Key的个数决定了冲突率（或者用负载因子衡量），再合理的范围内，key越多自然hash表空间越大，消耗的内存自然也会很大。再加上大量指针本身是长整型，所以内存存储的膨胀十分可观。先来谈谈如何把key的个数减少。 大家先来了解一种存储结构。我们期望将key1=&gt;value1存储在redis中，那么可以按照如下过程去存储。先用固定长度的随机散列md5(key)值作为redis的key，我们称之为BucketId，而将key1=&gt;value1存储在hashmap结构中，这样在查询的时候就可以让client按照上面的过程计算出散列，从而查询到value1。 过程变化简单描述为：get(key1) -&gt; hget(md5(key1), key1) 从而得到value1。 如果我们通过预先计算，让很多key可以在BucketId空间里碰撞，那么可以认为一个BucketId下面挂了多个key。比如平均每个BucketId下面挂10个key，那么理论上我们将会减少超过90%的redis key的个数。 具体实现起来有一些麻烦，而且用这个方法之前你要想好容量规模。我们通常使用的md5是32位的hexString（16进制字符），它的空间是128bit，这个量级太大了，我们需要存储的是百亿级，大约是33bit，所以我们需要有一种机制计算出合适位数的散列，而且为了节约内存，我们需要利用全部字符类型（ASCII码在0~127之间）来填充，而不用HexString，这样Key的长度可以缩短到一半。 下面是具体的实现方式 12345678910111213public static byte [] getBucketId(byte [] key, Integer bit) &#123; MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;); mdInst.update(key); byte [] md = mdInst.digest(); byte [] r = new byte[(bit-1)/7 + 1];// 因为一个字节中只有7位能够表示成单字符 int a = (int) Math.pow(2, bit%7)-2; md[r.length-1] = (byte) (md[r.length-1] &amp; a); System.arraycopy(md, 0, r, 0, r.length); for(int i=0;i&lt;r.length;i++) &#123; if(r[i]&lt;0) r[i] &amp;= 127; &#125; return r;&#125; 参数bit决定了最终BucketId空间的大小，空间大小集合是2的整数幂次的离散值。这里解释一下为何一个字节中只有7位可用，是因为redis存储key时需要是ASCII（0~127），而不是byte array。如果规划百亿级存储，计划每个桶分担10个kv，那么我们只需2^30=1073741824的桶个数即可，也就是最终key的个数。 5.3 减少碎片碎片主要原因在于内存无法对齐、过期删除后，内存无法重新分配。通过上文描述的方式，我们可以将人口标签和mapping数据按照上面的方式去存储，这样的好处就是redis key是等长的。另外对于hashmap中的key我们也做了相关优化，截取cookie或者deviceid的后六位作为key，这样也可以保证内存对齐，理论上会有冲突的可能性，但在同一个桶内后缀相同的概率极低(试想id几乎是随机的字符串，随意10个由较长字符组成的id后缀相同的概率*桶样本数=发生冲突的期望值&lt;&lt;0.05,也就是说出现一个冲突样本则是极小概率事件，而且这个概率可以通过调整后缀保留长度控制期望值)。而value只存储age、gender、geo的编码，用三个字节去存储。 另外提一下，减少碎片还有个很low但是有效的方法，将slave重启，然后强制的failover切换主从，这样相当于给master整理的内存的碎片。 推荐Google-tcmalloc， facebook-jemalloc内存分配，可以在value不大时减少内存碎片和内存消耗。有人测过大value情况下反而libc更节约。 md5散列桶的方法需要注意的问题1）kv存储的量级必须事先规划好，浮动的范围大概在桶个数的十到十五倍，比如我就想存储百亿左右的kv，那么最好选择30bit~31bit作为桶的个数。也就是说业务增长在一个合理的范围（10~15倍的增长）是没问题的，如果业务太多倍数的增长，会导致hashset增长过快导致查询时间增加，甚至触发zip-list阈值，导致内存急剧上升。 2）适合短小value，如果value太大或字段太多并不适合，因为这种方式必须要求把value一次性取出，比如人口标签是非常小的编码，甚至只需要3、4个bit（位）就能装下。 3）典型的时间换空间的做法，由于我们的业务场景并不是要求在极高的qps之下，一般每天亿到十亿级别的量，所以合理利用CPU租值，也是十分经济的。 4）由于使用了信息摘要降低了key的大小以及约定长度，所以无法从redis里面random出key。如果需要导出，必须在冷数据中导出。 5）expire需要自己实现，目前的算法很简单，由于只有在写操作时才会增加消耗，所以在写操作时按照一定的比例抽样，用HLEN命中判断是否超过15个entry，超过才将过期的key删除，TTL的时间戳存储在value的前32bit中。 6）桶的消耗统计是需要做的。需要定期清理过期的key，保证redis的查询不会变慢。 测试结果人口标签和mapping的数据100亿条记录。 优化前用2.3T，碎片率在2左右；优化后500g，而单个桶的平均消耗在4左右。碎片率在1.02左右。查询时这对于cpu的耗损微乎其微。 另外需要提一下的是，每个桶的消耗实际上并不是均匀的，而是符合多项式分布的。 上面的公式可以计算桶消耗的概率分布。公式是唬人用的，只是为了提醒大家不要想当然的认为桶消耗是完全均匀的，有可能有的桶会有上百个key。但事实并不没有那么夸张。试想一下投硬币，结果只有两种正反面。相当于只有两个桶，如果你投上无限多次，每一次相当于一次伯努利实验，那么两个桶必然会十分的均匀。概率分布就像上帝施的魔咒一样，当你面对大量的桶进行很多的广义的伯努利实验。桶的消耗分布就会趋于一种稳定的值。接下来我们就了解一下桶消耗分布具体什么情况： 通过采样统计31bit（20多亿）的桶，平均4.18消耗 桶消耗 占比 1 14.9% 2 17.7% 3 15.7% 4 13.9% 5 11.4% 6 9.6% 7 7% 8 4.8% 9 3.2% 10 1.7% 11 0.8% 12 &lt;0.2% 100亿节约了1.8T内存。相当于节约了原先的78%内存，而且桶消耗指标远没有达到预计的底线值15。 对于未出现的桶也是存在一定量的，如果过多会导致规划不准确，其实数量是符合二项分布的，对于2^30桶存储2^32kv，不存在的桶大概有（百万级别，影响不大）： 1Math.pow((1 - 1.0 / Math.pow(2, 30)), Math.pow(2, 32)) * Math.pow(2, 30); 对于桶消耗不均衡的问题不必太担心，随着时间的推移，写入时会对HLEN超过15的桶进行削减，根据多项式分布的原理，当实验次数多到一定程度时，桶的分布就会趋于均匀（硬币投掷无数次，那么正反面出现次数应该是一致的），只不过我们通过expire策略削减了桶消耗，实际上对于每个桶已经经历了很多的实验发生。 总结：信息摘要在这种场景下不仅能节约key存储，对齐了内存，还能让Key按照多项式分布均匀的散列在更少量的key下面从而减少膨胀，另外无需在给key设置expire，也很大程度上节约了空间。 这也印证了时间换空间的基本理论，合理利用CPU租值也是需要考虑的。","tags":[{"name":"redis","slug":"redis","permalink":"ly2513.github.com/tags/redis/"}]},{"title":"sudo 命令情景分析","date":"2017-02-28T10:36:50.000Z","path":"2017/02/28/sudo-命令情景分析/","text":"Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。 情景一：用户无权限执行 root 命令普通用户登录 shell 之后，如果自身没有权限访问某个文件或执行某个命令时，若该用户获得root授权，那么就可以在需要执行的命令之前加上 sudo，临时切换到root用户的权限，完成相关的操作。在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码，而sudo使一般用户不需要知道超级用户的密码即可获得权限。那么哪些用户可以临时获得 root 权限呢？这就需要在 /etc/sudoers 文件中进行配置：授权给单个用户： 1liyong ALL=(ALL) ALL 上面这个例子中： liyong：允许使用 sudo 的用户名ALL：允许从任何终端（任何机器）使用 sudo(ALL)：允许以任何用户执行 sudo 命令ALL：允许 sudo 权限执行任何命令 如果我们想让用户 test 只能在本主机（主机名为liyong-pc）以 root 账户执行/bin/chown、/bin/chmod 两条命令，那么就应该这样配置： 1test liyong-pc=(root) /bin/chown,/bin/chmod 和授权给单个用户类似，只不过将用户名在这里换成%组名，所有在该组中的用户都按照此规则进行授权。对于该例，所有在 sudo 组内的用户都有在任何终端（第一个ALL）、以任何用户（第二个ALL）、执行任何命令（第三个ALL）的权限，查看 /etc/group 文件可以知道哪些用户属于 sudo 组。 举例: 如果当前帐号在 /etc/sudoers 文件中被授予 sudo 的权限，那么你就可以将任何 root 命令作为 sudo 命令的参数，使用 root 权限来执行该命令。举例来说，挂载一个文件系统只能由 root 来执行，但是一个普通用户也可以使用 sudo 来挂载： 首次使用会要求你输入当前用户的密码，系统确实输入正确即以 root 权限来执行 mount 命令，接下来一段时间（默认为5分钟）再次使用 sudo 命令就不需要输密码了。 1sudo mount 情景二：vim 编辑后发现忘记使用 sudo我们经常会遇到这样的一个囧境：使用 vim 对某个文件进行编辑，编辑完之后，按 ESC 之后回到普通模式，再按 :wq 准备保存退出时，发现没有权限对该文件进行修改，我们在使用 vim 命令时忘记在前面加 sudo 了。我就经常出现这种问题，之前的做法是只能不保存强退，再加上 sudo 重新编辑。 但是今后我们再也不需要用这么愚蠢的做法了，我们可以在 vim 的普通模式下，按 :w !sudo tee % ，这样就可以 root 权限来保存文件了，你也无需因为自己一时忘记加个 sudo 而沮丧懊恼了！ 情景三：执行 root 命令忘记加 sudo我们还会遇到这样稍微好一点的情形：输入一个长长的命令，按 Enter 之后出现无权限操作，因为我们忘记加 sudo 了。大多人的做法是按 ↑ 回到上一条命令，在该命令之前加上 sudo，再执行该命令。 以后，我们无需这样了，只要输入 sudo !! 即可，这里的 !! 代表上一条命令。如： 情景四：shell 内置命令如何使用 sudoshell 是一个交互式的应用程序，在执行外部命令时通过 fork 来创建一个子进程，再通过 exec 来加载外部命令的程序来执行，但是如果一个命令是 shell 内置命令，那么只能直接由 shell 来运行。sudo 的意思是，以别的用户（如root）的权限来 fork 一个进程，加载程序并运行，因此 sudo 后面不能跟 shell 的内置命令，如： 在这种情况，我们又没有 root 账户的密码，我们怎样执行该命令呢？有种办法就是使用 sudo 获得root shell 的权限，然后在root shell 中执行该命令。进入root shell 很简单，输入sudo bash 确认本用户的密码即可，此时你会发现命令提示符显示当前是 root。一旦获得root shell，你可以执行任何命令而不需要在每条命令前输入sudo了。 另外，常用的shell 内置命令在这里 有简单介绍，我们可以使用 type 命令来查看命令的类型，如： 情景五：sudo 操作记录日志 作为一个 Linux 系统的管理员，不仅可以让指定的用户或用户组作为root用户或其它用户来运行某些命令，还能将指定的用户所输入的命令和参数作详细的记录。而sudo的日志功能就可以用户跟踪用户输入的命令，这不仅能增进系统的安全性，还能用来进行故障检修。但是要记录sudo的日志还要一些简单的配置： 参考资料： sudo mannual7 Linux sudo Command Tips and Trickssudo 日志配置","tags":[{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"Nginx性能调优","date":"2017-02-28T10:10:28.000Z","path":"2017/02/28/Nginx性能调优/","text":"Nginx以高性能的负载均衡器，缓存，和web服务器闻名，驱动了全球超过 40% 最繁忙的网站。在大多数场景下，默认的Nginx和Linux 设置可以很好的工作，但要达到最佳性能，有些时候必须做些调整。本文将讨论当调优系统时要考虑的一些Nginx和Linux设置。 有太多可以调优的设置，但本文只涵盖一小部分设置，这些设置对大多数使用者有优化的好处。本文不包括那些设置，那些需要必须深入理解Nginx和Linux，或者需要Nginx支持团队或专业服务团队指导才能做的设置。专业服务团队已经和很多全球热门网站共事，调优Nginx以达到最高性能，他们可以与你一起共事，充分利用Nginx或Nginx部署。 简介本文假设你已经对 Nginx 架构和配置的概念有一个基本的理解，本文不会重复 Nginx 文档，但会提供各种选项的概述和相关文档的链接。 调优的时候要遵循的一个准则：一次只改一个设置，如果对性能无有效提升，就改回默认值。 我们先从讨论Linux调优开始，因为一些操作系统配置的设置决定了如何优化Nginx的配置。 调优Linux 的配置Linux 内核（2.6以上）的设置已经适用于大多数场合，不过对一些设置的调整，会有更大的收益。如果系统配置太低，检查错误信息的内核日志则会提示建议升级。在这里我们只涉及最有可能在常规工作负载下调优很有收益的配置。调整配置的更多细节，请参考Linux文档。 缓冲区队列下面的设置与连接及其如何排队相关。如果传入连接速率很高，导致性能参次不齐（例如一些连接似乎停滞了），改变这些配置会有效。 net.core.somaxconn：排队等待连接的最大数目，由NGINX可接受的数目决定。默认值通常很低，但可以接受，因为NGINX 接收连接非常快，但如果网站流量大时，就应该增加这个值。内核日志中的错误消息会提醒这个值太小了，把值改大，直到错误提示消失。注意： 如果设置这个值大于512，相应地也要改变NGINX listen指令的backlog参数。net.core.netdev_max_backlog ： 在提交到CPU前网卡中数据包缓冲的速率，高带宽下提高这个值可提高性能。检查内核日志文件中有关这个设置的错误，根据网卡文档中的建议修改这个值。 文件描述符文件描述符是操作系统资源，用于表示连接、打开的文件，以及其他信息。NGINX 每个连接可以使用两个文件描述符。例如，如果NGINX充当代理时，通常一个文件描述符表示客户端连接，另一个连接到代理服务器，如果开启了HTTP 保持连接，这个比例会更低（译注：为什么更低呢）。对于有大量连接服务的系统，下面的设置可能需要调整一下： sys.fs.file_max —— 文件描述符系统级别的限制nofile —— 用户级别文件描述符限制，在 /etc/security/limits.conf 文件中修改。 临时端口当NGINX充当代理时，每个到上游服务器的连接都使用一个短暂或临时端口。可能需要修改这些设置： net.ipv4.ip_local_port_range —— 端口值的起止范围。如果你发现用尽端口号，可以增大端口范围。一般端口号设置是1024到65000。 调优NGINX配置以下是一些可以影响性能的NGINX指令。如上所述，我们只讨论自己能调整的指令。我们建议你在没有NGINX团队指导下，不要调整别的指令。 工作进程NGINX可以运行多个工作进程，每个都可处理大量并发连接。可以控制工作进程数，用下面的指令管理它们的连接： worker_processes —— NGINX工作进程数（默认值是1）。在大多数情况下，一个CPU内核运行一个工作进程最好，建议将这个指令设置成自动就可以。有时可能想增大这个值，比如当工作进程需要做大量的磁盘I/O。worker_connections —— 每个工作进程可以处理并发的最大连接数。默认值是512，但多数系统有充足的资源可以支撑更多的连接。合适的设置可以根据服务器的大小和流量的性质决定，可以通过测试修改。 长连接长连接对性能有很大的影响，通过减少CPU和网络开销需要开启或关闭连接。NGINX终止所有客户端连接，创建到上游服务器独立的连接。NGINx支持客户端和上游服务器两种长连接。下面是和客户端的长连接相关的指令： keepalive_requests-单个客户端长连接可以请求的数量，默认值是100，但是当使用压力测试工具从一个客户端发送多个请求测试时，这个值设更高些特别有用。keepalive_timeout—空闲长连接保持打开状态的时间。 下面是和上游服务器长连接的相关指令： keepalive –每个工作进程中空闲长连接到上游服务器保持开启的连接数量。没有默认值。 要使用连接到上游服务器的长连接，必须要配置文件中下面的指令。 12proxy_http_version 1.1;proxy_set_header Connection \"\"; 访问日志记录每个请求会消耗CPU和I/O周期，一种降低这种影响的方式是缓冲访问日志。使用缓冲，而不是每条日志记录都单独执行写操作，NGINX会缓冲一连串的日志记录，使用单个操作把它们一起写到文件中。 要启用访问日志的缓存，就涉及到在access_log指令中buffer=size这个参数。当缓冲区达到size值时，NGINX会把缓冲区的内容写到日志中。让NGINX在指定的一段时间后写缓存，就包含flush=time参数。当两个参数都设置了，当下个日志条目超出缓冲区值或者缓冲区中日志条目存留时间超过设定的时间值，NGINX都会将条目写入日志文件。当工作进程重新打开它的日志文件或退出时，也会记录下来。要完全禁用访问日志记录的功能，将access_log 指令设置成off参数。 Sendfile操作系统的sendfile()系统调用可以实现从一个文件描述符到另一个文件描述符的数据拷贝，通常实现零拷贝，这能加速TCP数据传输。要让NGINX使用它，在http或server或location环境中包含sendfile指令。NGINX可以不需要切换到用户态，就把缓存或磁盘上的内容写入套接字 ，而且写的速度非常快，消耗更少的CPU周期。注意，尽管使用sendfile()数据拷贝可以绕过用户态，这不适用于常规的NGINX处理改变内容的链和过滤器， 比如gzip。当配置环境下有sendfile指令和激活内容更改过滤器的指令时，NGINX会自动禁用sendfile。 限制你可以设置多个限制，防止用户消耗太多的资源，避免影响系统性能和用户体验及安全。 以下是相关的指令： limit_conn and limit_conn_zone—NGINX接受客户连接的数量限制，例如单个IP地址的连接。设置这些指令可以防止单个用户打开太多的连接，消耗超出自己的资源。limit_rate–传输到客户端响应速度的限制（每个打开多个连接的客户消耗更多的带宽）。设置这个限制防止系统过载，确保所有客户端更均匀的服务质量。limit_req and limit_req_zone– NGINX处理请求的速度限制，与limit_rate有相同的功能。可以提高安全性，尤其是对登录页面，通过对用户限制请求速率设置一个合理的值，避免太慢的程序覆盖你的应用请求（比如DDoS攻击)。max_conns上游配置块中服务器指令参数。在上游服务器组中单个服务器可接受最大并发数量。使用这个限制防止上游服务器过载。设置值为0（默认值）表示没有限制。queue (NGINX Plus) – 创建一个队列，用来存放在上游服务器中超出他们最大max_cons限制数量的请求。这个指令可以设置队列请求的最大值，还可以选择设置在错误返回之前最大等待时间（默认值是60秒）。如果忽略这个指令，请求不会放入队列。 缓存和压缩可以提高性能Nginx的一些额外功能可用于提高Web应用的性能，调优的时候web应用不需要关掉，但值得一提，因为它们的影响可能很重要。 它们包括缓存和压缩。 缓存一个启用Nginx缓存的情景，一组web或者应用服务器负载均衡，可以显著缩短对客户端的响应时间，同时大幅度降低后端服务器的负载。缓存本身就可以作个专题来讲，这里我们就不试图讲它了。参阅Nginx Plus管理手册的NGINX内容缓存。 压缩所以使用更小的网络带宽。然而尽管压缩数据会消耗CPU资源，但当需要减少网络带宽使用时这样做非常有效。需要注意的是，不能对已压缩的文件再压缩例如JPEG 文件。有关更多的信息，请参阅“Nginx Plus管理指南”中的压缩和解压缩。 了解更多信息，参阅以下： • Benchmarking NGINX: 4 Ways to Improve Accuracy (whitepaper)• NGINX documentation at nginx.org• NGINX and NGINX Plus Feature Matrix• NGINX Plus Technical Specifications","tags":[{"name":"nginx","slug":"nginx","permalink":"ly2513.github.com/tags/nginx/"}]},{"title":"PHP命令行下的世界","date":"2017-02-28T09:48:37.000Z","path":"2017/02/28/PHP命令行下的世界/","text":"PHP作为一门web开发语言，通常情况下我们都是在Web Server中运行PHP，使用浏览器访问，因此很少关注其命令行操作以及相关参数的使用，但是，特别是在类Unix操作系统上，PHP可以作为一门脚本语言执行与shell类似的处理任务。 PHP命令行(CLI)参数详解查看PHP的所有命令行参数，使用php -h命令。我们将会对大部分常用的命令行参数进行一一解释，以加深对PHP能力的认识，更加快捷的在服务端命令行下使用PHP或者调试各种因为对环境不熟悉而出现的问题。 -a 以交互式shell模式运行-c | 指定php.ini文件所在的目录-n 指定不使用php.ini文件-d foo[=bar] 定义一个INI实体，key为foo，value为’bar’-e 为调试和分析生成扩展信息-f 解释和执行文件. -h 打印帮助-i 显示PHP的基本信息-l 进行语法检查 (lint)-m 显示编译到内核的模块-r 运行PHP代码，不需要使用标签 ..?&gt;-B 在处理输入之前先执行PHP代码-R 对输入的没一行作为PHP代码运行-F Parse and execute for every input line-E Run PHP after processing all input lines-H Hide any passed arguments from external tools.-S : 运行内建的web服务器.-t 指定用于内建web服务器的文档根目录-s 输出HTML语法高亮的源码-v 输出PHP的版本号-w 输出去掉注释和空格的源码-z 载入Zend扩展文件 . args… 传递给要运行的脚本的参数. 当第一个参数以-开始或者是脚本是从标准输入读取的时候，使用–参数 –ini 显示PHP的配置文件名 –rf 显示关于函数 的信息.–rc 显示关于类 的信息.–re 显示关于扩展 的信息.–rz 显示关于Zend扩展 的信息.–ri 显示扩展 的配置信息. 上面列出了PHP命令所有的参数及其注释，接下来，我们将对其中比较常用的参数举例说明。 以交互式shell模式运行php 用过 Python 的朋友对Python的交互式shell比较熟悉，在命令行下，如果我们直接输入python命令，则会进入python的交互式shell程序，接下来就可以交互式的执行一些计算任务。 在PHP命令行中，同样提供了类似的功能，使用-a参数即可进入交互shell模式。 在该shell中，我们可以执行一些简单的任务，而不需要总是新建一个php文件。 更详细的使用说明，请参考官方文档 运行内建的Web服务器 从PHP 5.4.0开始，PHP的命令行模式提供了一个内建的web服务器。使用-S开始运行web服务。 假设当前我们处在目录/usr/local/var/www/php/demo，在该目录中，存在index.php文件。 1234$ lsindex.php$ cat index.php&lt;?php echo \"Hello, PHPER!\"; 在该目录中，执行以下命令可以启动内建web服务器，并且默认以当前目录为工作目录 12345$ php -S localhost:8000PHP 5.6.3 Development Server started at Wed Jun 10 15:49:41 2015Listening on http://localhost:8000Document root is /Users/mylxsw/codes/php/aicode/demoPress Ctrl-C to quit. 我们另外开启一个shell窗口，请求http://localhost:8000/即可看到脚本输出 123456789$ curl -is http://localhost:8000/HTTP/1.1 200 OKHost: localhost:8000Connection: closeX-Powered-By: PHP/5.6.3Content-type: text/html;Hello, PHPER! 在web服务运行的窗口，可以看到输出的日志信息 以上我们在启动内建服务器的时候，只指定了-S参数让PHP以web服务器的方式运行，这时，PHP会使用当前目录作为工作目录，因此回到当前目录下寻找请求的文件，我们还可以使用-t参数指定其它的目录作为工作目录（文档根目录）。 更多详细信息，请参考官方文档。 查找PHP的配置文件 在有的时候，由于服务器上软件安装比较混乱，我们可能安装了多个版本的PHP环境，这时候，如何定位我们的PHP程序使用的是那个配置文件就比较重要了。在PHP命令行参数中，提供了–ini参数，使用该参数，可以列出当前PHP的配置文件信息。 1234567891011$ php --iniConfiguration File (php.ini) Path: /usr/local/etc/php/5.6Loaded Configuration File: /usr/local/etc/php/5.6/php.iniScan for additional .ini files in: /usr/local/etc/php/5.6/conf.dAdditional .ini files parsed: (none)$ /usr/local/php/bin/php --iniConfiguration File (php.ini) Path: /usr/local/php/etc/Loaded Configuration File: /usr/local/php/etc/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 上述的服务器上我们安装了两个版本的PHP，由上可以看到，使用php –ini命令可以很方便的定位当前PHP命令将会采用哪个配置文件。 查看类/函数/扩展信息 通常，我们可以使用php –info命令或者在在web服务器上的php程序中使用函数phpinfo()显示php的信息，然后再查找相关类、扩展或者函数的信息，这样做实在是麻烦了一些。 1234$ php --info | grep redisredisRegistered save handlers =&gt; files user redisThis program is free software; you can redistribute it and/or modify 我们可以使用下列参数更加方便的查看这些信息 –rf 显示关于函数 的信息.–rc 显示关于类 的信息.–re 显示关于扩展 的信息.–rz 显示关于Zend扩展 的信息.–ri 显示扩展 的配置信息. 例如，我们希望查看扩展redis的配置信息 123456$ php --ri redisredisRedis Support =&gt; enabledRedis Version =&gt; 2.2.7 查看redis类的信息 1234567891011$ php --rc redisClass [ class Redis ] &#123; - Constants [19] &#123; Constant [ integer REDIS_NOT_FOUND ] &#123; 0 &#125; ... - Methods [201] &#123; ... Method [ public method echo ] &#123; &#125; ... 查看函数printf的信息 12345678$ php --rf printfFunction [ function printf ] &#123; - Parameters [2] &#123; Parameter #0 [ $format ] Parameter #1 [ ...$args ] &#125;&#125; 语法检查 有时候，我们只需要检查php脚本是否存在语法错误，而不需要执行它，比如在一些编辑器或者IDE中检查PHP文件是否存在语法错误。 使用-l（–syntax-check）可以只对PHP文件进行语法检查。 12$ php -l index.phpNo syntax errors detected in index.php 假如此时我们的index.php中存在语法错误 12345$ php -l index.phpPHP Parse error: syntax error, unexpected 'echo' (T_ECHO) in index.php on line 3Parse error: syntax error, unexpected 'echo' (T_ECHO) in index.php on line 3Errors parsing index.php 命令行脚本开发 在使用PHP开发命令行脚本的时候，与开发web程序是明显不同的，在web程序中，我们可以通过改变url的参数，为PHP环境提供不同的输入，但是在命令行脚本程序中如何获取外部的输入呢？ 在使用C语言开发程序时，我们通常会在main函数中提供两个可选的参数int main(int argc, char *argv[])，这两个参数就是从命令行提供的输入参数。在PHP中，提供了两个全局变量$argc和$argv用于获取命令行输入。 $argc 包含了 $argv数组包含元素的数目$argv 是一个数组，包含了提供的参数，第一个参数总是脚本文件名称假设我们有一个名为console.php的命令行脚本文件 123456&lt;?phpecho '命令行参数个数: ' . $argc . \"n\";echo \"命令行参数:n\";foreach ($argv as $index =&gt; $arg) &#123; echo \" &#123;$index&#125; : &#123;$arg&#125;n\";&#125; 在命令行下执行该脚本 123456$ php console.php hello world命令行参数个数: 3命令行参数: 0 : console.php 1 : hello 2 : world 可以看到，第0个参数是我们执行的脚本名称。需要注意的是，如果提供的第一个参数是以-开头的话，需要在前面增加–，以告诉php这后面的参数是提供给我们的脚本的，而不是php执行文件的（php -r ‘var_dump($argv);’ — -h）。 另外，在脚本中，我们可以通过php_sapi_name()函数判断是否是在命令行下运行的 12$ php -r 'echo php_sapi_name(), PHP_EOL;'cli","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"}]},{"title":"最全的常用正则表达式大全","date":"2017-02-28T09:10:19.000Z","path":"2017/02/28/最全的常用正则表达式大全/","text":"很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，包括校验数字、字符、一些特殊的需求等等。给自己留个底，也给朋友们做个参考。 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9″$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) (由@飞龙三少 提供，感谢共享)","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"},{"name":"正则","slug":"正则","permalink":"ly2513.github.com/tags/正则/"}]},{"title":"每天掌握一个Linux命令(10): cat命令","date":"2017-02-28T08:53:06.000Z","path":"2017/02/28/每天掌握一个Linux命令-10-cat命令/","text":"cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 1.命令格式 cat [选项] [文件]… 2.命令功能 cat主要有三大功能： 1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 3.命令参数 -A, –show-all 等价于 -vET-b, –number-nonblank 对非空输出行编号-e 等价于 -vE-E, –show-ends 在每行结束处显示 $-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行-t 与 -vT 等价-T, –show-tabs 将跳格字符显示为 ^I-u (被忽略)-v, –show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 4.使用实例 例一：把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里命令：cat -n log2012.log log2013.log 例二：把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里。命令：cat -b log2012.log log2013.log log.log 输出：12345678[root@localhost test]# cat -b log2012.log log2013.log log.log 1 2012-01 2 2012-02 3 ====== 4 2013-01 5 2013-02 6 2013-03 7 ======[root@localhost test]# 例三：把 log2012.log 的文件内容加上行号后输入 log.log 这个文件里命令：cat -n log2012.log &gt; log.log 输出: 12345678[root@localhost test]# cat -n log2012.log &gt; log.log[root@localhost test]# cat -n log.log 1 2012-01 2 2012-02 3 4 5 ======[root@localhost test]# 例四：使用here doc来生成文件输出： 1234567891011121314[root@localhost test]# cat &gt;log.txt &lt;&lt;EOF&gt; Hello&gt; World&gt; Linux&gt; PWD=$(pwd)&gt; EOF[root@localhost test]# ls -l log.txt-rw-r--r-- 1 root root 37 10-28 17:07 log.txt[root@localhost test]# cat log.txtHelloWorldLinuxPWD=/opt/soft/test[root@localhost test]# 说明： 注意粗体部分，here doc可以进行字符串替换。 备注：tac (反向列示) 命令：tac log.txt 输出： 12345[root@localhost test]# tac log.txtPWD=/opt/soft/testLinuxWorldHello 说明： tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(9): touch命令","date":"2017-02-28T08:38:42.000Z","path":"2017/02/28/每天掌握一个Linux命令-9-touch命令/","text":"linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。 1.命令格式 命令 touch [选项]… 文件… 2.命令参数 -a 或–time=atime或–time=access或–time=use 只更改存取时间。-c 或–no-create 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 或–time=mtime或–time=modify 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。 3.命令功能 touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 4.使用范例 例一：创建不存在的文件命令：touch log2012.log log2013.log 输出： 1234567[root@localhost test]# touch log2012.log log2013.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log 如果log2014.log不存在，则不创建文件 命令: touch -c log2014.log 1234567[root@localhost test]# touch -c log2014.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log 例二：更新log.log的时间和log2012.log时间戳相同命令：touch -r log.log log2012.log 输出： 1234567891011121314151617[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log[root@localhost test]# touch -r log.log log2012.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log 例三：设定文件的时间戳命令：touch -t 201211142234.50 log.log 说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969–2068之内．MM为月数，DD为天将把年数CCYY限定在1969–2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0–61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(8): cp命令","date":"2017-02-28T08:29:02.000Z","path":"2017/02/28/每天掌握一个Linux命令-8-cp命令/","text":"cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 1.命令格式 命令： cp [选项]… [-T] 源 目的或：cp [选项]… 源… 目录或：cp [选项]… -t 目录 源… 2.命令功能 将源文件复制至目标文件，或将多个源文件复制至目标目录。 3.命令参数 -a, –archive 等于-dR –preserve=all–backup[=CONTROL 为每个已存在的目标文件创建备份-b 类似–backup 但不接受参数–copy-contents 在递归处理是复制特殊文件内容-d 等于–no-dereference –preserve=links-f, –force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项)-i, –interactive 覆盖前询问(使前面的 -n 选项失效)-H 跟随源文件中的命令行符号链接-l, –link 链接文件而不复制-L, –dereference 总是跟随符号链接-n, –no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, –no-dereference 不跟随源文件中的符号链接-p 等于–preserve=模式,所有权,时间戳–preserve[=属性列表 保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, –recursive 复制目录及目录内的所有项目 4.命令实例 例一：复制单个文件到目标目录，文件在目标文件中不存在命令：cp log.log test5 说明： 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 例二：目标文件存在时，会询问是否覆盖命令：cp log.log test5 说明： 目标文件存在时，会询问是否覆盖。这是因为cp是cp -i的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖。 例三：复制整个目录,将整个test2目录下的文件复制到test3命令：cp -r test2 test3 说明： 注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。 例四：复制的 log.log 建立一个连结档 log_link.log命令：cp -s log.log log_link.log 说明： 那个 log_link.log 是由 -s 的参数造成的，建立的是一个『快捷方式』，所以您会看到在文件的最右边，会显示这个文件是『连结』到哪里去的！","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(7): mv命令","date":"2017-02-28T08:18:42.000Z","path":"2017/02/28/每天掌握一个Linux命令-7-mv命令/","text":"mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 1.命令格式 mv [选项] 源文件或目录 目标文件或目录 2.命令功能 视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。 3.命令参数 -b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 4.命令实例 例一：文件改名,将文件test.log重命名为test1.txt命令：mv test.log test1.txt 例二：移动文件,将test1.txt文件移到目录test3中命令：mv test1.txt test3 例三：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。命令： mv log1.txt log2.txt log3.txt test3 mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt 说明： mv log1.txt log2.txt log3.txt test3 命令将log1.txt ，log2.txt， log3.txt 三个文件移到 test3目录中去，mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt 命令又将三个文件移动到test4目录中去 例四：将文件file1改名为file2，如果file2已经存在，则询问是否覆盖命令：mv -i log1.txt log2.txt 例五：将文件log3.txt改名为log2.txt，即使log2.txt存在，也是直接覆盖掉。命令：mv -f log3.txt log2.txt 例六：目录的移动,如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中。命令：mv dir1 dir2 例七：移动当前文件夹下的所有文件到上一级目录命令：mv * ../ 例八：把当前目录的一个子目录里的文件移动到另一个子目录里命令：mv test3/*.txt test5 例九：文件被覆盖前做简单备份，前面加参数-b命令：mv log1.txt -b log2.txt 输出： 12345678910111213[root@localhost test5]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-25 17:56 test5-1[root@localhost test5]# mv log1.txt -b log2.txtmv：是否覆盖“log2.txt”? y[root@localhost test5]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt~-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-25 17:56 test5-1[root@localhost test5]# 说明： -b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。–backup该选项指定如果目标文件存在时的动作，共有四种备份策略： 1.CONTROL=none或off : 不备份。 2.CONTROL=numbered或t：数字编号的备份 3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1…n： 执行mv操作前已存在以数字编号的文件log2.txt.~1~，那么再次执行将产生log2.txt~2~，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。 4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(6): rmdir命令","date":"2017-02-27T02:00:03.000Z","path":"2017/02/27/每天掌握一个Linux命令-6-rmdir命令/","text":"今天学习一下linux中命令： rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm – r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。 1.命令格式 rmdir [选项]… 目录… 2.命令功能 该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 3.命令参数 -p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。 如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 -v, –verbose 显示指令执行过程 4命令实例 例一：rmdir 不能删除非空目录命令：rmdir doc 输出：1234567891011121314151617181920212223242526272829303132[root@localhost scf]# tree.|-- bin|-- doc| |-- info| `-- product|-- lib|-- logs| |-- info| `-- product`-- service `-- deploy |-- info `-- product12 directories, 0 files[root@localhost scf]# rmdir docrmdir: doc: 目录非空[root@localhost scf]# rmdir doc/info[root@localhost scf]# rmdir doc/product[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| |-- info| `-- product`-- service `-- deploy |-- info `-- product10 directories, 0 files 说明： rmdir 目录名 命令不能直接删除非空目录 例二：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除命令：rmdir -p logs 输出：12345678910111213141516171819202122232425262728293031323334353637[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| `-- product`-- service `-- deploy |-- info `-- product10 directories, 0 files[root@localhost scf]# rmdir -p logsrmdir: logs: 目录非空[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| `-- product`-- service `-- deploy |-- info `-- product9 directories, 0 files[root@localhost scf]# rmdir -p logs/product[root@localhost scf]# tree.|-- bin|-- doc|-- lib`-- service`-- deploy |-- info `-- product7 directories, 0 files – 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(5): rm命令","date":"2017-02-26T14:42:49.000Z","path":"2017/02/26/每天掌握一个Linux命令-5-rm命令/","text":"昨天学习了创建文件和目录的命令mkdir ，今天学习一下linux中删除文件和目录的命令： rm命令。rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。 1.命令格式 rm [选项] 文件… 2.命令功能 删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 3.命令参数： -f, –force 忽略不存在的文件，从不给出提示。 -i, –interactive 进行交互式删除 -r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, –verbose 详细显示进行的步骤 –help 显示此帮助信息并退出 –version 输出版本信息并退出 4.命令实例： 例一：删除文件file，系统会先询问是否删除。命令：rm 文件名 输入rm log.log命令后，系统会询问是否删除，输入y后就会删除文件，不想删除则数据n。 例二：强行删除file，系统不再提示。命令：rm -f log1.log 例三：删除任何.log文件；删除前逐一询问确认命令：rm -i *.log 例四：将 test1子目录及子目录中所有档案删除命令：rm -r test1 例五：rm -rf test2命令会将 test2 子目录及子目录中所有档案删除,并且不用一一确认命令：rm -rf test2 例六：删除以 -f 开头的文件命令：rm – -f 例七：自定义回收站功能命令：myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv “$@” $D &amp;&amp; echo “moved to $D ok”; } 输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243[root@localhost test]# myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv \"$@\" $D &amp;&amp; echo \"moved to $D ok\"; &#125;[root@localhost test]# alias rm='myrm'[root@localhost test]# touch 1.log 2.log 3.log[root@localhost test]# ll总计 16-rw-r--r-- 1 root root 0 10-26 15:08 1.log-rw-r--r-- 1 root root 0 10-26 15:08 2.log-rw-r--r-- 1 root root 0 10-26 15:08 3.logdrwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# rm [123].logmoved to /tmp/20121026150901 ok[root@localhost test]# ll总计 16drwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# ls /tmp/20121026150901/1.log 2.log 3.log[root@localhost test]# 说明： 上面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。 – 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(4):mkdir命令","date":"2017-02-26T14:27:59.000Z","path":"2017/02/26/每天掌握一个Linux命令-4-mkdir命令/","text":"linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 1.命令格式 mkdir [选项] 目录… 2.命令功能 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 3.命令参数 -m, –mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, –parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v, –verbose 每次创建新目录都显示信息 –help 显示此帮助信息并退出 –version 输出版本信息并退出 4.命令实例 例一：创建一个空目录命令：mkdir test1 例二：递归创建多个目录命令：mkdir -p test2/test22 实例三：创建权限为777的目录命令：mkdir -m 777 test3 例四：创建新目录都显示信息命令：mkdir -v test4 例五：一个命令创建项目的目录结构命令：mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}} 输出： 1234567891011121314[root@localhost test]# mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;mkdir: 已创建目录 “scf”mkdir: 已创建目录 “scf/lib”mkdir: 已创建目录 “scf/bin”mkdir: 已创建目录 “scf/doc”mkdir: 已创建目录 “scf/doc/info”mkdir: 已创建目录 “scf/doc/product”mkdir: 已创建目录 “scf/logs”mkdir: 已创建目录 “scf/logs/info”mkdir: 已创建目录 “scf/logs/product”mkdir: 已创建目录 “scf/service”mkdir: 已创建目录 “scf/service/deploy”mkdir: 已创建目录 “scf/service/deploy/info”mkdir: 已创建目录 “scf/service/deploy/product” – 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(3):pwd命令","date":"2017-02-26T14:17:08.000Z","path":"2017/02/26/每天掌握一个Linux命令-3-pwd命令/","text":"Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 1.命令格式 pwd [选项] 2.命令功能 查看”当前工作目录“的完整路径 3.常用参数 一般情况下不带任何参数 如果目录是链接时： -P 显示出实际路径，而非使用连接（link）路径。 4.常用实例 例一：用 pwd 命令查看默认工作目录的完整路径命令：pwd 例三：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径命令：pwd -P 例四：/bin/pwd命令：/bin/pwd [选项] 选项： -L 目录连接链接时，输出连接路径-P 输出物理路径 例五：当前目录被删除了，而pwd命令仍然显示那个目录– 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"每天掌握一个Linux命令(2): cd命令","date":"2017-02-26T14:03:12.000Z","path":"2017/02/26/每天掌握一个Linux命令-2-cd命令/","text":"Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。 1.命令格式 cd [目录名] 2.命令功能 切换当前目录至dirName 3.常用范例 例一：进入系统根目录命令：cd / 例二：使用 cd 命令进入当前用户主目录“当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。 命令： cd cd ~ 例三：跳转到指定目录命令：cd /opt/soft 例四：返回进入此目录之前所在的目录命令：cd – 例五：把上个命令的参数作为cd参数使用。命令：cd !$ – 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"RAP接口文档导入到postman","date":"2017-02-22T07:49:08.000Z","path":"2017/02/22/RAP接口文档导入到postman/","text":"我司采用阿里开源的RAP系统管理API文档。但实际中我们后端为了调试所写的API是否正确,常用Google提供的postman(Paw、fireFox的httpRequester)等这类工具模拟浏览器发送http请求所写API。之前是手工一个一个的写API地址,这样的做法非常耗时,为了提高开发效率,就想能否用Rap导出的API json文件生成相应的postman的相应的请求的API目录,这样一来就不需要手工的一个一个写API地址了。为了实现,我将导出的RapAPI的json文件进行研究发现,这文件里的API很有规律。于是写了一段PHP代码对这文件进行处理,最后生成postman想要的格式的json文件。以下就是将rap的接口文档导出的API生成的json文件处理后成为postman的json文件的代码, php代码如下： 12345678910111213141516171819202122232425262728293031323334$data = file_get_contents('rap备份文件路径');$data = json_decode($data,TRUE);$data['modelJSON'] = str_replace(\"\\'\",'\\\"',$data['modelJSON']);$data = json_decode($data['modelJSON'],TRUE);$postMan = [];$postMan['info']['name'] = $data['name'];$postMan['info']['_postman_id'] = md5(microtime(TRUE));$postMan['info']['schema'] = \"https://schema.getpostman.com/json/collection/v2.0.0/collection.json\";$postMan['item'] = [];foreach ($data['moduleList'] as &amp;$module) &#123; foreach ($module['pageList'] as &amp;$page) &#123; $p = []; $p['name'] = $page['name']; foreach ($page['actionList'] as &amp;$action) &#123; $a = []; $a['name'] = $action['name']; $a['request']['url'] = '&#123;&#123;url&#125;&#125;/'.trim($action['requestUrl'],'/'); $a['request']['method'] = ($action['requestType']==1) ? 'GET' : 'POST'; $a['request']['header']['token'] = '&#123;&#123;token&#125;&#125;'; $a['request']['body']['mode'] = 'urlencoded'; foreach ($action['requestParameterList'] as &amp;$requestParameter) &#123; $r['key'] = $requestParameter['identifier']; $r['value'] = \"\"; $r['type'] = \"text\"; $r['enabled'] = TRUE; $a['request']['body']['urlencoded'][] = $r; &#125; $p['item'][] = $a; &#125; $postMan['item'][] = $p; &#125;&#125;file_put_contents(\"输出目录/postman.json\", json_encode($postMan));#echo json_encode($postMan);die; 处理后得到的postman的json文件,然后导入到postman。这样就减少了之前一个一个API手写的功夫了。 如对你有用,尽管拿去,不用谢。。。。。。","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"},{"name":"postman","slug":"postman","permalink":"ly2513.github.com/tags/postman/"},{"name":"rap","slug":"rap","permalink":"ly2513.github.com/tags/rap/"}]},{"title":"每日掌握一个Linux命令(1): ls命令","date":"2017-02-21T14:32:14.000Z","path":"2017/02/21/每日掌握一个Linux命令-1-ls命令/","text":"ls命令是linux系统中常用的命令之一。ls命令是list缩写,该命令用于列出当前目录下所有的文件夹及文件.如果ls指定某个目录那么就会显示指定目录下的文件夹及文件。通过ls命令不仅可以查看linux下文件夹所包含的文件及文件夹而且可以查看文件的权限(包括目、文件夹、文件权限)查看目录信息等。 1.命令格式 ls [选项] [目录名] 2.命令功能 列出当前目录的所有文件夹及文件 3.常用参数 -a, -all 列出目录下的所有文件,包括以.开头的隐藏文件及目录 -A同-a,但不列出”.”(表示当前目录)和”..”(表示当前目录的父目录) -c 配合 -lt: 根据ctime排序及显示ctime(文件状态最后更改的时间)配合 -l:显示ctime但根据名称排序否则:根据ctime排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序 -C 每栏由上至下列出项目 –color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一 -d, –directory 将目录象文件一样显示，而不是显示其下的文件。 -D, –dired 产生适合 Emacs 的 dired 模式使用的结果 -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效 -g 类似 -l,但不列出所有者 -G, –no-group 不列出任何有关组的信息 -h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G) -t 以文件修改时间排序 -u 配合 -lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -w, –width=COLS 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 –help 显示此帮助信息并离开 –version 显示版本信息并离开 –si 类似 -h,但文件大小取 1000 的次方而不是 1024 -H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p) -i, –inode 印出每个文件的 inode 号 -I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目 -k 即 –block-size=1K,以 k 字节的形式表示文件的大小。 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息 -m 所有项目以逗号分隔，并填满整行行宽 -o 类似 -l,显示文件的除组信息外的详细信息。 -r, –reverse 依相反次序排列 -R, –recursive 同时列出所有子目录层 -s, –size 以块大小为单位列出所有文件的大小 -S 根据文件大小排序 4.常用范例 例一：列出/home/liyong文件夹下的所有文件和目录的详细资料命令：ls -l -R /home/liyong 例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：命令：ls -l t* 例三：只列出文件下的子目录命令：ls -F /opt/soft |grep /$ 例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：命令：ls -ltr s* 例五：列出目前工作目录下所有档案及目录;目录于名称后加”/”, 可执行档于名称后加”*”命令：ls -AF 例六：计算当前目录下的文件数和目录数命令： ls -l |grep “^-“|wc -l —文件个数ls -l |grep “^d”|wc -l —目录个数 例七: 在ls中列出文件的绝对路径命令：ls | sed “s:^:pwd/:” 例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld 例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径命令：find $PWD | xargs ls -ld 例十一：指定文件时间输出格式命令：ls -tl –time-style=full-iso – 原文链接","tags":[{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"ly2513.github.com/tags/linux/"}]},{"title":"mac常用的命令汇总","date":"2016-12-28T15:04:30.000Z","path":"2016/12/28/mac常用的命令汇总/","text":"Mac 终端命令大全目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w","tags":[{"name":"mac","slug":"mac","permalink":"ly2513.github.com/tags/mac/"},{"name":"shell","slug":"shell","permalink":"ly2513.github.com/tags/shell/"}]},{"title":"mac包管理工具 -- brew ","date":"2016-12-28T03:45:31.000Z","path":"2016/12/28/mac包管理工具-brew/","text":"熟悉centOS的同学很清楚yum、rpm这类工具,他们都是centOS下的包管理工具,熟悉Ubuntu的同学也对apt很了解,这就不多说了。使用mac的同学就会问了,mac有类似的的工具吗?它在mac下是怎么安装的,该工具又是怎样使用的呢?接下来就这几个问题进行”报道”。 问题一、它是谁了答案: 它就是brew,它的全称是Homebrew 问题二、它怎么安装了答案: 查看你的mac有没有安装ruby,没装的的话,自己google啊,在此就不介绍了,如果安装使用如下命令 1ruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\" 由于Homebrew的安装地址可能变化，请到官方网站查看最新的安装方法。 问题三、它怎么使用了 其基本使用方法如下(以mysql为例) 查找软件包 1brew search mysql 安装软件包 1brew install mysql 删除软件包 1brew remove mysql 查看软件包信息 1brew info mysql 列出软件包的依赖关系 1brew deps mysql 列出已安装的软件包 1brew list 更新brew 1brew update 列出所有安装的软件包里可以升级的那些 1brew outdated 升级全部的软件包 1brew upgrade 升级某个软件包 1brew upgrade mysql 清理不需要的版本极其 1brew cleanup 你还可以定制自己的软件包如果自己需要的软件包并不能在Homebrew中找到，怎么办呢，毕竟Homebrew是一个新生项目，不可能满足所有人的需求。当然，我们可以自行编译安装，但手工安装的软件包游离于Homebrew之外，管理起来不是很方便。 前文说过，Homebrew使用Ruby实现的软件包配置非常方便，下面简单谈一谈软件包的定制（假定软件包名称是bar，来自foo站点）。 首先找到待安装软件的源码下载地址 1http://foo.com/bar-1.0.tgz 建立自己的formula 1brew create http://foo.com/bar-1.0.tgz 编辑formula，上一步建立成功后，Homebrew会自动打开新建的formula进行编辑，也可用如下命令打开formula进行编辑。 1brew edit bar Homebrew自动建立的formula已经包含了基本的configure和make install命令，对于大部分软件，不需要进行修改，退出编辑即可。 输入以下命令安装自定义的软件包1brew install bar 以上就是brew常用的命令了,关于Homebrew的其它功能，比如将自定义软件包提交到官方发布等，请参考Homebrew项目的主页及其Man Page。你将发现Homebrew不仅是“家酿”，更是“佳酿”。","tags":[{"name":"mac","slug":"mac","permalink":"ly2513.github.com/tags/mac/"},{"name":"brew","slug":"brew","permalink":"ly2513.github.com/tags/brew/"}]},{"title":"mac上那些好用的tools","date":"2016-12-27T14:32:37.000Z","path":"2016/12/27/mac上那些好用的tools/","text":"Awesome Mac  这个仓库主要是收集非常好用的Mac应用程序、软件以及工具，主要面向开发者和设计师。有这个想法是因为我最近发了一篇较为火爆的涨粉儿微信公众号文章《工具武装的前端开发工程师》，于是建了这么一个仓库，持续更新作为补充，搜集更多好用的软件工具。请Star、Pull Request或者使劲搓它 issues 给我推荐优秀好用的Mac应用，很显然我是一个资深Mac用户，我需要它们帮助我快乐、高效的工作，同时也分享给你。格式参照awesome的清单。 在这里非常感谢 @GitHubDaily 的推荐 说明 表示 开源软件 ，点击进入 开源 仓库； 表示 免费 使用，或者个人 免费 ； 表示 热门 的软件； 表示 推荐 的软件； 表示 装机必备 的软件； 表示 App store 连接地址; 表示 强烈推荐 的必装神器，数量来表达强烈的程度； 目录 编辑器 开发者工具 测试工具 命令行工具 版本控制 数据库 设计和产品 虚拟机 通信 数据恢复 音频和视频 书签阅读写作 FTP客户端 软件打包工具 制作电子书 下载工具 网盘 输入法 浏览器 翻译工具 科学上网 其它实用工具 远程协助 第三方应用市场APP Mac软件下载网站 编辑器一种用于编辑纯文本文件的程序，建议使用免费开源的编辑器 Atom - GitHub推出的开源编辑器，Atom常用插件。 Sublime Text - 一个比较简洁大方带插件管理系统的流行编辑器，Sublime常用插件。 Brackets - Adobe推出的Brackets免费/开源编辑器。 Visual Studio Code - 微软推出的免费/开源编辑器，TypeScript支持杠杠的。 Emacs - Emacs是基于控制台的编辑器和高度可定制的。 LightTable - 下一代代码编辑器。 TextMate - 文本编辑器软件，与BBedit一起并称苹果机上的emacs和vim，这是以前。 BBEdit - 强大的文件编辑器，用于编辑文件，文本文件及程序源代码。 Coda2 - 编写Web应用长得漂亮的编辑器。 Vim - Vim古老命令行中使用的编辑器。 Vundle.vim - Vim插件管理工具。 vim-plug - 一个简约的vim插件管理器。 WebVim - 倾向于开发JavaScript和Web的vim。 vim-web - 一个前端开发工程师的vim。 Neovim - 提高Vim可扩张灵活性。 Spacevim - 模仿Spacemacs的使用方式。 Spf13 - 一套全方位的配置项目。 Vimr - Vim客户端，升级Vim体验。 HBuilder - HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。 Tincta - 一个免费的文本编辑器。 IntelliJ IDEA - 一款Java开发集成环境。(学生免费) Webstorm - 是jetbrains公司旗下一款JavaScript开发工具。 学生免费，点击这里 查看更多。 一些很好的插件 NodeJS - 集成Node.js，你肯定需要它，很多功能需要它。 EditorConfig - 帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格。 Material Theme UI - Google为React开发的主题。 Deco IDE - React Native IDE 支持控件拖拽界面实时变更。 Xamarin Studio - 免费的跨平台的C# IDE。支持iOS、Android和.net开发。 NetBeans IDE - 免费、开源的IDE，主要用于java开发，可支持多种语言和框架。 Eclipse - 流行的开源IDE，主要用于Java，但为多种语言和平台的插件支持。 开发者工具 WeFlow - 一个基于 tmt-workflow 前端工作流的开发工具。 Koala - 预处理器语言图形编译工具，支持Less、Sass、CoffeeScript、Compass framework 的即时编译。 CodeKit - 自动编译Less、Sass、Stylus、CoffeeScript、Jade &amp; Haml等文件。 Hosts.prefpane - 编辑 hosts 文件的工具。 iHosts - 唯一上架 Mac App Store 的 /etc/hosts 编辑神器。 SwitchHosts - 一个管理、切换多个 hosts 方案的工具。 Gas Mask - 编辑 hosts 文件的工具，更简单方便。 DiffMerge - 可视化的文件比较（也可进行目录比较）与合并工具。 Beyond Compare - 对比两个文件夹或者文件，并将差异以颜色标示。 Kaleidoscope - 一款很强大的文本文件和图像比较工具，同时和 git、svn 等版本控制工具能够完美的结合。 Fanvas - 把swf转为HTML5 canvas动画的系统。 EnvPane - 图形终端查看环境变量的应用工具。 Dash - 强大到你无法想象的API离线文档软件。 Dlite - 简单的使用Docker的一个软件。 SnippetsLab - 管理和组织你的代码片段。 StarUML - 强大的软件建模软件。 Vagrant Manager - 管理你本地服务。 zeplin - 前端与设计协同工作专用工具。 Go2Shell - 从Finder打开命令行。 SecureCRT - 一款支持SSH、Telnet等多种协议的终端仿真程序。 MJML - 简化设计回应电子邮件的方式。 TeXstudio - 集成创建LaTeX文档的写作环境。 Vagrant - 用来构建虚拟开发环境的工具。 正则编辑器 Patterns - 正则表达式编辑器。 Reginald - 正则表达式测试应用程序，使用 RegexKitLite。 Regex - 感觉是用过最漂亮的正则表达式测试工具。 Reggy - 正则表达式编辑器。 RegExRX - 正则表达式的开发工具。 测试工具 Charles - 一个代理工具，允许你查看所有的HTTP和HTTPS流量。 Insomnia 3.0 - 漂亮的HTTP请求测试工具。 Cocoa Rest Client - 比Postman看起来漂亮的客户端，测试HTTP/REST endpoints。 Paw - 先进的 HTTP 客户端。 Cellist - HTTP调试客户端。 Integrity - 轻松找到无效链接。 Postman - Postman 帮助我们快速测试API。 命令行工具 iTerm2 - 免费的终端工具，直接替代自带的Terminal，有非常多惊人的特性。 cool-retro-term - 怀旧的命令行终端。 Oh my zsh - 拥有大量的有用的功能，助手，插件，主题，等特性的命令行工具插件。 Glances - 在命令行中查看你系统运行状态的工具。 Cakebrew - Homebrew 的客户端软件。摆脱命令方便安装、查看、卸载软件。 ndm - 查看本地NPM安装的包客户端软件。摆脱命令方便安装、查看、卸载软件。 Black Screen - 来自 21 世纪的强大终端。 Fish Shell - 智能且用户友好的命令行终端。 oh-my-fish - 和Oh my zsh相似，建立在Fish Shell框架上。 bash-it - 一个社区的bash的框架。 color-retro-term - 一款复古风格的终端，非常酷炫。 HyperTerm - 一款基于Node开发的终端软件，逼格很高。 itunes-remote - 通过终端控制您的iTunes。 mycli - 为MySQL命令行客户端，提供语法高亮和提示功能的工具！ LNav - 日志文件阅读器. tmux 终端登录远程主机的命令行工具。 mas - 一个简单的命令行界面的苹果应用商店。 版本控制 Git - 版本控制工具，官网提供数十种GUI客户端 for Mac。 SVN - 版本控制工具。 GUI Gitbar - 开源，在你的菜单栏上显示GitHub贡献统计。 GitHub Desktop - 使用GitHub的GUI应用。 Oh My Star - GitHub的star功能弱，比如分类，本地组织你的GitHub star! GitUp - 一个简单功能强大的git客户端。 Hub - 将GitHub接口和git命令进行包装。 SourceTree - 强大的Git跨平台客户端。 Tower2 - 最强大的Git客户端。 Versions - Mac上最好的SVN管理工具。 Cornerstone - Mac上最佳的SVN管理工具。 版本控制系统 GitLab - 一个用于仓库管理系统的开源项目。 GitHub GitHub代码托管，项目管理，演示部署，瞧，您现在就访问GitHub。 Coding.net - 代码托管，项目管理，WebIDE，演示部署，开启云端开发模式，让开发更简单。 phabricator phabricator支持Git、SVN、HG 基于 PHP + Mysql 的开放源代码软件开发平台。 Gogs - 一款极易搭建的自助 Git 服务Golang版本。 Gerrit Gerrit 是一个免费、开放源代码的代码审查软件，使用网页界面。 Gitblit Java版本Git代码托管，项目管理。 数据库 Sequel Pro - 一个MySQL数据库管理软件。 MySQL Workbench - MySQL数据库官方管理软件。 Postico - 现代PostgreSQL客户端，漂亮功能多。 ElectroCRUD - MySQL数据库CRUD应用程序。 Base 2 - 一个用于管理SQLite数据库的软件。 Postgres.app - Mac上最简单的方法的使用PostgreSQL关系型数据库管理系统。 PSequel - PostgreSQL数据库GUI软件。 Robomongo - 基于Shell的MongoDB图形化客户端管理软件。 MongoBooster - MongoDB图形化管理软件，内嵌MongoShell，ES6语法，流畅查询及智能感知。 Mongo Management Studio - MongoDB图形化客户端管理软件。 MongoChef - MongoDB图形化客户端管理软件。 Chrome MySQL Admin - 一个Chrome插件，是MySQL开发的跨平台、可视化数据库工具。 JackDB - 直接的SQL访问你所有的数据，无论在哪里。 medis - 漂亮的Redis管理软件。 RedisDesktopManager - Redis跨平台的GUI管理工具。 MDB Explorer - Mac上查看编辑Access数据库的工具。 Datum - SQLite - Sqlite3数据库管理软件。 mongoDB.app - 在Mac 上最简单的使用MongoDB DataGrip - 是jetbrains公司旗下一款数据库管理工具。点击这里 学生免费。 设计和产品设计工具 Acorn - 一个像PS，全面的功能集的图像编辑器。 Affinity Designer - 矢量图像设计工具，可能的Adobe Illustrator的替代。 Affinity Photo - 光栅图像设计工具，可以替代Adobe PS图象处理软件。 Blender - 全功能可扩展的跨平台3D内容套件。 Pixelmator - 强大的图像编辑器，可能PS图像处理软件的选择。 Sketch - 混合矢量/位图布局应用，特别适用于用户界面，Web和移动设计。 Sketch Toolbox - 一个超级简单的Sketch插件管理器。 inklet - 将Mac上的触摸板变成绘图板。 Monodraw - 一款文本图像编辑器。 SketchBook - 出众的绘图软件。 Tayasui Sketches - 专业的绘图软件。 Nik Collection - 专业照片后期制作工具Google收购后免费。 Paintbrush - 位图图像编辑器。 Krita - 一个开源的位图形编辑软件，包含一个绘画程式和照片编辑器。 Vectr - 免费图形编辑器。这是一个简单而强大的Web和桌面跨平台工具，把你的设计变成现实。 Principle - 使用它很容易设计动画和交互式用户界面。 MagicaVoxel - 轻量级的8位像素编辑和交互路径追踪渲染器。 ScreenToLayers - 轻松导出桌面分层文件PSD文件。 原型流程 Justinmind - 功能更丰富团队协作方便。 MockFlow - 用于网页设计和可用性测试的在线原型设计套件。 Axure RP 8 - 画原型图工具，团队协作SVN方便好用。 Mockplus - 更快更简单的原型设计工具。 OmniGraffle - 可用来绘制图表、流程图、组织结构图、思维导图以及插图或原型。 XMind - 一款实用的思维导图软件。 Scapple - 一款实用的思维导图软件。 Framer - 做交互原型的工具。 Balsamiq Mockups - 一个快速的网页设计原型工具，帮助你更快、更聪明的工作。 Marvel - 简单设计，原型设计和协作。 MindNode - 简洁的风格与人性化的操作，绘制思维脑图。 其它工具 Notes - 简洁的笔记应用。 TinyPNG4Mac - 图片压缩专用开源工具。 Image2icon - 将你的图片转换成图标。 ImageAlpha - 压缩PNG图片，去掉无效的透明。 ImageOptim - 压缩图片，删除EXIF信息。 Sip - 收集，整理和分享你的颜色拾色器。 Frank DeLoupe - 支持 Retina 的屏幕拾色器。 ColorSchemer - 专业的配色、调色软件。 IconKit - App图标自动生成器。 Licecap - 是一款屏幕录制工具输出GIF，录制过程中可以随意改变录屏范围。 Kap - 轻量 GIF 录屏小工具。 GIPHY Capture - 免费软件的捕捉和分享图片在桌面上。 Skitch - 截图附带强大的标注功能。 截图(Jietu) - 截图附带强大的标注功能，腾讯作品。 Snip - 高效的截图工具，支持滚动截屏，腾讯作品。 iPic - 上传插图链接分享。 Iconjar - 图标管理软件，带组织和搜索功能。 RightFont - 字体管理工具。 Solarized - 干净清爽的颜色主题，支持iTerm、Intellij IDEA、Vim等。 虚拟机 Parallels Desktop - 虽然好用但是收费机制，更新花钱、花钱、花钱。 Virtual Box - 免费、免费、免费，带NTFS读写，不用买ParagonNTFS，省100块。 VMWare Fusion - 强大的虚拟机，商业软件。 Veertu - Mac上最轻便的虚拟机，只有跑Windows才会收费。比较新，很多功能不支持。 通信推荐一些通信工具，沟通，团队协同。 Franz - 一个使用 Electron开发的，可以同时登录23个平台的即时通讯软件。 QQ - QQ for Mac App。 WeChat - 微信 for Mac App。 Electronic WeChat - 调用微信接口，使用 Electron 开发的第三方漂亮开源微信应用。 Skype - Skype共享、跨平台的短信和电话。 WeiboX - 微博第三方Mac应用。 御飯 - 饭否第三方Mac应用。 ChitChat - WhatsApp非官方。 Telegram - 通讯新时代。 Messenger - Facebook第三方聊天工具。 Adium - 呃这个是老的集成多个平台的聊天客户端。 Textual - 最受欢迎的世界与我们相关的KPI应用 for OS X。 Gitter - 关于GitHub的项目交流，支持 Markdown，对开发者极为友好。 简聊 - 企业级即时沟通工具，已经下线了，可以自己搭建一套系统玩儿。 钉钉 - 企业级办公通讯免费平台。 Slack - 团队协作，沟通工具。 零信 - 随时随地工作，跨平台。 今目标 - 一款面向中小企业的互联网工作平台。 BearyChat - 互联网团队协作，沟通工具。 Bitpost - 私人分散消息。它是一个p2p的去中心化和无须第三方提供信用担保协议。 Teambition - 团队协作。提供管理任务、安排日程、查找文件、即时讨论等团队所需要的一切协作功能。 日事清 - 个人日程管理，团队协作工具。日程安排，计划分配，笔记总结等。 Coding.net - 代码托管，项目管理，WebIDE，演示部署，开启云端开发模式，让开发更简单。 WeeChat - 一个命令行聊天客户端。 Email Spark - 新推出的快速邮件客户端支持Mac和iPhone。 Airmail - 快速的邮件客户端支持Mac和iPhone。 Foxmail - 快速的邮件客户端。 MailTags - 管理和组织邮件，日程和标签进行分类邮件。 N1 - 可以扩展的开源收费邮件客户端。 Postbox - 这个貌似也非常强大哦，关键是简洁漂亮的收费邮件客户端。 Polymail - 简单，功能强大，长得好看的新晋邮件客户端。 CloudMagic Email - 界面非常简洁的一个邮件客户端。 ThunderBird - Mozilla 公司出品的强大的Email客户端程序。 数据恢复 DiskWarrior - 恢复文件系统损坏时，磁盘工具进行选择。 Data Rescue - 多种情况下的全面和专业的数据恢复。 Stellar Phoenix Mac Data Recovery - 一个功能强大的恢复文件面向Mac的工具。 R-Studio for Mac - 可恢复分区被格式化、损坏或被删除的文件。 音频和视频 Kodi - 一款一流的免费开源媒体中心软件，可用于播放视频、音乐，查看图片，玩游戏等. MPV - 一个免费、开源和跨平台的媒体播放器。 VOX Player - 免费全能音乐播放器，撸码之余听听歌是一种享受。 Radiant Player - Google Play音乐播放器。 Sonora - 一个很小的音乐播放器。 Audacity - 免费开源的编辑音频的软件。 Audio Hijack - 一个记录任何应用程序的音频，包括网络电话Skype，网络流从Safari，以及更多。 Stringed 2 - 音频编辑处理工具。 Mixxx - 免费的DJ软件，给你一切你需要的表演组合，名副其实的替代Traktor。 Cog - 一个免费的开源音频播放器。 VLC - 开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件。 XLD - 解码/解码/转换/播放各种“无损”音频文件。 HandBrake - 高性能的视频编码和转换工具，具有很好的图形用户界面。 MPlayerX - 媒体播放器。 ScreenFlow - 屏幕和视频编辑软件。 ArcTime - 跨平台字幕制作软件。 Perian - 让QuickTime播放所有常见格式的免费插件。 书签阅读写作 OpenOffice - 是一套跨平台的办公室软件套件。 Spillo - 功能强大，美观、快速网络书签网页阅读。 iChm - 读chm文件的软件。 Chmox - 读chm文件的软件。 CHM Reader - 读chm文件的软件。 Kindle App - 亚马逊 Kindle App 电子书阅读器。 RSS Feeds 2 - 监控任何RSS。 ReadKit - 书签RSS管理客户端。 Reeder 3 - RSS 服务订阅。 Leaf - RSS 客户端程序。 Vienna - RSS/Atom 新闻阅读客户端。 Markdown Mou - 免费 Markdown 编辑神器。 Marp - Markdown 制作幻灯片编辑器。 TextNut - Markdown编辑器，富文本之间自由切换。 MWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件。 Typora - 基于 Electron 的“读写一体” Markdown 编辑器。 MacDown - 一款开源的Markdown编辑器，深受Mou的影响。 EME - 最近刚出的一款Markdown编辑器，界面很像Chrome浏览器的界面，很简约。 LightPaper - 简单的Markdown文本编辑器。 Cmd Markdown - Cmd Markdown 编辑阅读器，支持实时同步预览，区分写作和阅读模式，支持在线存储，分享文稿网址。 笔记 Quiver - 程序猿的笔记本。 有道云笔记 - 支持多目录，Markdown，iWork/Office预览。 为知笔记 - 支持Markdown，搜集整理图片链接导入文档。 leanote - 支持Markdown的一款开源笔记软件，支持直接成为个人博客。 Inkdrop - Markdown爱好者的笔记本应用程序。 制作电子书 Calibre - 丑陋的软件，但强大的软件电子书管理和转换。 Sigil - 多平台EPUB编辑器 FTP客户端 Transmit - 一个FTP客户端，支持FTP + SFTP + S3。 Flow - 支持简单的 FTP + SFTP 客户端。 Yummy FTP - 专业快速，可靠的FTP客户端。 Cyberduck - 免费FTP，SFTP，S3和WebDAV客户端 &amp; OpenStack Swift Client。 FileZilla - 跨平台的FTP，FTPS和SFTP客户端。 软件打包工具 Finicky - Web应用程序转化为苹果的应用程序。 nw.js - 使用HTML和JavaScript来制作桌面应用。 Electron - 前身是 AtomShell，使用 JS、HTML 和CSS 构建跨平台的桌面应用程序。 react-desktop - 为 macOS Sierra带来React UI组件。 React Native Desktop for Mac - 用 React Native 技术构建 OS X 下的桌面应用程序。 React Native Desktop for Ubuntu - 用 React Native 技术构建 Ubuntu 下的桌面应用程序。 AppJS - 使用 JS、HTML 和CSS 构建跨平台的桌面应用程序。 HEX - 使用 JS、HTML 和CSS 构建跨平台的桌面应用程序，有道出品。 AlloyDesktop - 同上，腾讯出品，给个差评。 MacGap - 桌面WebKit打包HTML、CSS、JS应用。 ionic - 一个用来开发混合手机应用的，开源的，免费的代码库。 下载工具 Transmission - 免费的BitTorrent客户端 aria2 - 一款支持多种协议的轻量级命令行下载工具。 JDownloader - 下载工具，下载文件的一键式托管。 You-Get - 网络富媒体命令行下载工具。 Free Download Manager - 功能强大的下载加速器。 FOLX - Folx 是一个Mac osx 系统风格界面的下载管理工具。 网盘推荐一些有Mac客户端的网盘。 Dropbox - 非常好用的免费网络文件同步工具，提供在线存储服务。 百度云 - 百度云客户端。 腾讯微云 - 腾讯云客户端。 坚果云 - 坚果云客户端。 115 - 115云客户端。 360 - 360云客户端。 快盘 - 金山快盘。 owncloud - 私有云网盘。 Mega - 免费的云服务，提供50GB的免费存储空间。 亿方云 - 硅谷团队打造，个人免费。 Seafile - 是由国内团队开发的国际化的开源云存储软件项目。 输入法 QQ输入法 - 腾讯出品的输入法。 搜狗输入法 - 搜狗输入法。 百度输入法 - 支持拼音五笔输入。 清歌五笔输入法 - 为 iOS 和 Mac 专门打造的五笔输入法。 WBIM - 五笔输入法。 Rocket - Emoji标签输入。 颜文字 - 颜文字输入。 RIME - 中州韻輸入法引擎。 哈利路亚英文输入法 - 智能英文输入法，具备自动补全，自动纠错功能。 浏览器这里放Mac的浏览器应用 Safari - Mac预装自带浏览器。 Chrome - Chrome浏览器谷歌出品。 Firefox - 火狐浏览器。 Opera - Opera 浏览器。 QQ浏览器 - QQ浏览器－腾讯出品。 傲游云浏览器 - 傲游云浏览器。 Vivaldi - Opera开发商出品新的浏览器。 Ōryōki - 小的web浏览器。这是一个试验性的项目，目前正在开发中 翻译工具 有道翻译 - 有道词典桌面版。 辞海词典 - 学单词、背单词、辞海词典。 eudic - 欧路词典词典。 iTranslate - 支持全世界超过 80 种语言发音和输出。 科学上网假设你是个勤奋的同学，你总有一天会强烈需要它们，上帝保佑他们吧。 SpechtLite - 支持 Shadowsocks 及规则管理的高效率代理。 ShadowsocksX - 一个快速的隧道代理，可以帮助你绕过防火墙。 ShadowsocksX-NG - 一款ShadowsocksX客户端软件。 Lantern - 科学上网。 鱼摆摆 - 科学上网。 Tunnelblick - OpenVPN的免费软件。 GoAgentX - 科学上网。 Surge - 科学上网。 云梯 - 在圈内小有名气的VPN服务提供商。 srocket - 开启科学上网。 LoCoVPN - 每天签到可获得2小时免费VPN加速。 二师兄VPN - 提供无限流量、无限续期免费VPN账号。 GTX加速器 - 每天签到领取500M流量。 GreenVPN - 注册激活送免费VPN加速流量。 风驰VPN - 无限流量、无限续期的免费VPN加速服务。 开眼 - Chrome插件免费的科学上网利器。 其它实用工具 12306ForMac - Mac版12306 订票/捡票 助手。 AirServer - 将手机投影到电脑上。 CheatSheet - CheatSheet 是一款Mac上的非常实用的快捷键快速提醒工具。 WWDC - Mac OS的非官方的WWDC APP。 xScope - 测量、检查和测试屏幕上的图形和布局的工具。搜索你的苹果和网络，快速打开应用程序。 f.lux - 自动调整您的电脑屏幕，以匹配亮度。 Todoist - 跨平台的任务管理器与移动应用程序。 TaskPaper - 漂亮的纯文本任务列表。 Wunderlist - 奇妙清单跨平台的任务管理器与移动应用程序。 Ukelele - Unicode键盘布局编辑器。 Karabiner - 一个强大的和稳定的OS X的键盘定制。 Keytty - 让你通过键盘使用鼠标。 AppCleaner - 一个小应用程序，让你彻底卸载不需要的应用程序。 BetterZip 3 - 压缩解压缩工具支持格式 ZIP、TAR、TGZ、TBZ、TXZ (new)、7-ZIP、RAR。 Numi - 漂亮的计算器应用。 Fantastical - 日历应用程序，你将管理好生活。 OnyX - 多功能实用工具来验证磁盘和文件，运行清洁和系统维护任务，配置隐藏选项等。 SSH Tunnel - 管理你的SSH。 Mounty - NTFS 分区读写组件。 Paragon NTFS - 在Mac OS X中完全读写、修改、访问Windows NTFS硬盘、U盘等外接设备的文件。 Tuxera NTFS - Mac上的NTFS文件系统驱动。 gfxCardStatus - 控制Mac独立显卡与集成显卡之间的切换。 openEmu - 模拟器，可以玩魂斗罗之类，放松回到小时候。 Alfred - 效率神器。 Hammerspoon - 功能强大的自动化工具，Lua 脚本驱动，支持窗口管理。 DaisyDisk - 磁盘空间使用扫描工具。 iStat pro - 免费的Mac OS电脑硬件信息检测软件。 BitBar - 支持使用各种语言将信息展示到Mac OS的菜单栏。 ClipMenu - 一个剪贴板操作的管理器。 ControlPlane - 自定义Mac情景模式。比如你到了公司后可以让Mac自动静音或是自动打开Mail客户端，晚上回到家后自动打开iTunes听歌，到了公共场所自行修改网络设置等等。 Caffeine - 实用工具，菜单栏按钮，点击休眠。 Itsycal - 一款简洁实用的开源日历工具。 HTML5 Player - Chrome插件解决中国视频网站播放视频电脑发热的情况。 Monity - 帮助用户实时监控系统的一款非常漂亮的软件。 BetterTouchTool - 代替默认的系统操作方式（组合键、修饰键、手势等）。 iStats - iStats 是一个可以让你快速查看电脑 CPU 温度，磁盘转速和电池等信息的命令行工具。 InsomniaX - 合上盖子不眠不休，继续听歌下载。 NoSleep - 合上盖子不休眠，可根据是否连接电源单独设置。 窗口管理 ShiftIt - 窗口位置和大小管理软件。 Moom - 多任务多窗口的软件。 Slate - 窗口管理器，可用JavaScript写配置。 Amethyst - 窗口管理器（自动保持窗口大小的窗口）。 Spectacle - 简单的移动和调整大小的窗口，和可定制的键盘快捷键。 密码管理 1password - 跨平台帐号密码管理软件。 LastPass - 密码管理器和安全的数字笔记。 KeePassX - 一个免费的，开源的，体积小的密码管理器。 MacPass - 密码管理器。 Finder Quicklook-Plugins - Finder快速预览文件插件。 Path Finder - 强大的Finder替代者，拥有很多特性。 TotalFinder - 强大的Finder替代者，界面风格像Chrome。 XtraFinder - 给Finder添加有用的新特性。 远程协助 TeamViewer - 远程协助及在线协作和会议功能的软件，商业软件个人使用免费。 RealVNC 是一款免费的远程控制跨多平台的程序。 第三方应用市场APP这里讨论盗版问题或者提供黑名单？，拒绝盗版从我做起，欢迎大家监督。 正版这里只提供正版软件购买下载的应用商店。 HackStore - 一个类似于cydia的第三方Mac应用市场，平台拒绝盗版。 MacUpdate Desktop - 管理/更新/下载App，跟踪优惠信息。 homebrew-cask - 体验通过命令行安装Mac软件的工具。 应用商店黑名单第三方应用市场APP黑名单，存在盗版软件传播和下载，拒绝盗版从我做起，欢迎大家监督它们。 腾讯电脑管家 - 电脑管家for Mac 带应用市场。 迅雷Thunder Store - 迅雷Thunder for Mac 带应用市场。 Mac软件宝箱 - Macx推出软件宝箱。 MacHunter - Mac应用市场。 Mac软件下载网站这里主要是推荐一些软件下载的网站，还有一些Mac OSX软件分享网站 正版/介绍 MacUpdate：https://www.macupdate.com/ App Shopper：http://appshopper.com/ 类似于iOS上Cydia一样的第三方软件商店：http://hack-store.com 少数派：http://sspai.com/tag/Mac Mac玩儿法：http://www.waerfa.com 盗版软件下载网站黑名单上面有大量的开源软件或者免费软件，拒绝盗版从我做起，下面被删除的网站提供大量破解软件下载，欢迎大家监督它们。 玩转苹果：http://www.ifunmac.com Mac软件下载站：http://www.pshezi.com MacPeers：http://www.macpeers.com Mac志：http://www.isofts.org Mac软件分享：http://www.waitsun.com AppKed：http://www.macbed.com 苹果软件园：http://www.maczapp.com Mac精品软件：http://xclient.info/ Macx：http://www.macx.cn/ 腾牛网：http://www.qqtn.com/mac/r_17_1.html ⬆ 返回顶部 本文转载自: 原文github","tags":[{"name":"mac","slug":"mac","permalink":"ly2513.github.com/tags/mac/"}]},{"title":"PHP-CLI环境变量的设置和读取","date":"2016-12-27T14:32:37.000Z","path":"2016/12/27/PHP-CLI环境变量的设置和读取/","text":"场景 通常我们在维护PHP线上项目的时候，为了隔离配置和代码，会使用fastcgi_param的形式将环境变量定义在Nginx的配置文件中（Apache可以使用SetEnv指令）。这样在PHP-FPM运行过程中就可以使用getenv函数获取到环境变量的值了。 那对于PHP-CLI，我们又应该怎么设置它的环境变量呢？做法也很简单。 在终端直接执行： 1$ export ART_ENV=production 后续直接使用PHP-CLI命令的时候自然可以获取到环境变量ART_ENV的值： 12$ php -r \"var_dump(getenv('ART_ENV'));\"string(10) \"production\" 但是通常还有这种情况：我们当前登录的用户并不是合适的用来运行PHP-CLI脚本的用户，比如我们期待使用www-data用户来运行PHP-CLI脚本，通常我们会这样做： 12$ sudo -u www-data php -r \"var_dump(getenv('ART_ENV'));\"bool(false) 这时候就会发现无法获取到环境变量了。查看sudo –help可以发现我们还需要设置-E参数： 123$ sudo --help...-E, --preserve-env preserve user environment when running command 按照文档说明补上即可： 12$ sudo -E -u www-data php -r \"var_dump(getenv('ART_ENV'));\"string(10) \"production\" 或者更直接点直接指定环境变量的值： 12$ sudo -u www-data ART_ENV=testing php -r \"var_dump(getenv('ART_ENV'));\"string(7) \"testing\" 需要注意的是：这里的PHP代码都必须使用getenv函数获取环境变量，不能单纯依赖全局变量$_ENV。全局变量$_ENV并不总是可用的，除非在php.ini文件中显式设置了variables_order的值包含E，例如variables_order = “EGPCS”。更多的详细信息可以参考PHP文档的全局变量部分。","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"}]},{"title":"PHPExcel库使用手册","date":"2016-10-22T13:27:08.000Z","path":"2016/10/22/PHPExcel库使用手册/","text":"前言(说在前面的话) 作为开发人员,我们使用数据库来管理数据,但是作为公司的运营同事、销售同事。。不一定会使用一些客户端的数据库软件(sequel Pro、Navicat等),他们当中大多数习惯使用Excel来对数据进行操作。为了让公司的工作效率提高,作为研发的我需要将数据通过程序导入到特定的Excel中供其他同事使用。由于以上所谓的”理由”,本博客就这针对于PHPExcel库使用进行讲解。PHPExcel可是个好东东，功能强大，下面这是一个phpExcel简易中文帮助手册，列举了各种属性，以及常用的操作方法，是每一个都用实例加以说明，希望对大家有所帮助。 也许也有人不知道PHPExcel是什么 PHPExcel: 是用来操作Office Excel 文档的一个PHP类库，它基于微软的OpenXML标准和PHP语言。可以使用它来读取、写入不同格式的电子表格. 由于最近本人在实际的项目开发中需要使用这库做一些报表数据的录入,所以对这库进行了稍微深入的学习,并用此博客进行说明。 话就不多说,我们直接进入主题–怎么使用PHPExcel这扩展库 怎么使用PHPExcel这扩展库 首先你得先引用并实例化一个PHPExcel对象去操作Excel吧 12345678# 引用PHPExcelinclude 'PHPExcel.php';# 用于输出格式为.xlsxinclude 'PHPExcel/Writer/Excel2007.php';# 用于输出格式.xls的// include 'PHPExcel/Writer/Excel5.php';# 创建一个实例$objPHPExcel = new PHPExcel(); 设置属性 123456789101112131415# 创建人$objPHPExcel-&gt;getProperties()-&gt;setCreator(\"Maarten Balliauw\");# 最后修改人$objPHPExcel-&gt;getProperties()-&gt;setLastModifiedBy(\"Maarten Balliauw\");# 标题$objPHPExcel-&gt;getProperties()-&gt;setTitle(\"Office 2007 XLSX Test Document\");# 题目$objPHPExcel-&gt;getProperties()-&gt;setSubject(\"Office 2007 XLSX Test Document\");# 描述$objPHPExcel-&gt;getProperties()-&gt;setDescription(\"Test document for Office 2007 XLSX, generated using PHP classes.\");# 关键字$objPHPExcel-&gt;getProperties()-&gt;setKeywords(\"office 2007 openxml php\");# 种类$objPHPExcel-&gt;getProperties()-&gt;setCategory(\"Test result file\"); 同样你也可以这样设置,”一步到位”,”链式”设置 1234567$objPHPExcel-&gt;getProperties()-&gt;setCreator(\"ctos\") -&gt;setLastModifiedBy(\"ctos\") -&gt;setTitle(\"Office 2007 XLSX Test Document\") -&gt;setSubject(\"Office 2007 XLSX Test Document\") -&gt;setDescription(\"Test document for Office 2007 XLSX, generated using PHP classes.\") -&gt;setKeywords(\"office 2007 openxml php\") -&gt;setCategory(\"Test result file\"); 设置当前的sheet 1$objPHPExcel-&gt;setActiveSheetIndex(0); 设置sheet的标题 1$objPHPExcel-&gt;getActiveSheet()-&gt;setTitle('Simple'); 设置单元格宽度 1$objPHPExcel-&gt;getActiveSheet()-&gt;getColumnDimension('A')-&gt;setWidth(20); 设置单元格高度 1$objPHPExcel-&gt;getActiveSheet()-&gt;getRowDimension($i)-&gt;setRowHeight(40); 合并单元格 1$objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells('A18:E22'); 拆分单元格 1$objPHPExcel-&gt;getActiveSheet()-&gt;unmergeCells('A28:B28'); 设置保护cell,保护工作表 123$objPHPExcel-&gt;getActiveSheet()-&gt;getProtection()-&gt;setSheet(true);$objPHPExcel-&gt;getActiveSheet()-&gt;protectCells('A3:E13', 'PHPExcel'); 设置格式 123$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('E4')-&gt;getNumberFormat()-&gt;setFormatCode(PHPExcel_Style_NumberFormat::FORMAT_CURRENCY_EUR_SIMPLE);$objPHPExcel-&gt;getActiveSheet()-&gt;duplicateStyle( $objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('E4'), 'E5:E13' ); 设置字体加粗 1$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('B1')-&gt;getFont()-&gt;setBold(true); 设置水平对齐方式（HORIZONTAL_RIGHT，HORIZONTAL_LEFT，HORIZONTAL_CENTER，HORIZONTAL_JUSTIFY） 1$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('D11')-&gt;getAlignment()-&gt;setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_RIGHT); 设置垂直居中 1$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('A18')-&gt;getAlignment()-&gt;setVertical(PHPExcel_Style_Alignment::VERTICAL_CENTER); 设置字号 1$objPHPExcel-&gt;getActiveSheet()-&gt;getDefaultStyle()-&gt;getFont()-&gt;setSize(10); 设置边框 1$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('A1:I20')-&gt;getBorders()-&gt;getAllBorders()-&gt;setBorderStyle(\\PHPExcel_Style_Border::BORDER_THIN); 设置边框颜色12345678# 左边框$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('D13')-&gt;getBorders()-&gt;getLeft()-&gt;getColor()-&gt;setARGB('FF993300');# 上边框$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('D13')-&gt;getBorders()-&gt;getTop()-&gt;getColor()-&gt;setARGB('FF993300');# 下边框$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('D13')-&gt;getBorders()-&gt;getBottom()-&gt;getColor()-&gt;setARGB('FF993300');# 右边框$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('E13')-&gt;getBorders()-&gt;getRight()-&gt;getColor()-&gt;setARGB('FF993300'); 插入图像1234567891011121314151617$objDrawing = new PHPExcel_Worksheet_Drawing();# 设置图片路径 切记：只能是本地图片$objDrawing-&gt;setPath('图像地址');# 设置图片高度$objDrawing-&gt;setHeight(180);# 设置照片宽度$objDrawing-&gt;setWidth(150);# 设置图片要插入的单元格$objDrawing-&gt;setCoordinates('E2');# 设置X(水平)偏移量(相当于设置的单元格水平偏移,正数:水平右平移,负数:水平左平移)$objDrawing-&gt;setOffsetX(5);# 设置Y(垂直)偏移量(相当于设置的单元格垂直偏移,正数:垂直上平移,负数:垂直下平移)$objDrawing-&gt;setOffsetY(5);$objDrawing-&gt;setRotation(5);$objDrawing-&gt;getShadow()-&gt;setVisible(true);$objDrawing-&gt;getShadow()-&gt;setDirection(50);$objDrawing-&gt;setWorksheet($objPHPExcel-&gt;getActiveSheet()); 设置单元格背景色 12$objPHPExcel-&gt;getActiveSheet(0)-&gt;getStyle('A1')-&gt;getFill()-&gt;setFillType(\\PHPExcel_Style_Fill::FILL_SOLID);$objPHPExcel-&gt;getActiveSheet(0)-&gt;getStyle('A1')-&gt;getFill()-&gt;getStartColor()-&gt;setARGB('FFCAE8EA'); 数据写入 1$objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue('A1',$data); 最后输出到浏览器，导出Excel1234567891011121314$savename='导出Excel示例';$ua = $_SERVER[\"HTTP_USER_AGENT\"];$datetime = date('Y-m-d', time());if (preg_match(\"/MSIE/\", $ua)) &#123; $savename = urlencode($savename); //处理IE导出名称乱码&#125;# excel头参数header('Content-Type: application/vnd.ms-excel');# 日期为文件名后缀header('Content-Disposition: attachment;filename=\"'.$savename.'.xls\"');header('Cache-Control: max-age=0');#excel5为xls格式，excel2007为xlsx格式$objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5');$objWriter-&gt;save('php://output'); 输出到本地电脑123456# 输出到本地目录路径$path = /usr/local/;# 文件名称$fileName = $path.'测试Excel.xls';$objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5');$objWriter-&gt;save($path); 以上是本人在工作中用到的PHPExcel类库的方法,以上方法掌握了,对基本的Excel操作足矣。。。。如果要更深的操作就去看看PHPExcel原文的,稍微需要有点英语基础语言。","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"},{"name":"PHPExcel","slug":"PHPExcel","permalink":"ly2513.github.com/tags/PHPExcel/"}]},{"title":"她(三)","date":"2016-10-12T14:07:51.000Z","path":"2016/10/12/她(三)/","text":"她 –记录着我和她最近的一些事情,总想和她发生些故事,哈哈。。你别可歪想哦 ! ! ! 我只想和她在一起做一些我们都喜欢的事,举个栗子(旅行,吃饭,电影。。。)这篇博客接下来就是描述我们一起旅行—-西藏之旅,可以说这次旅行就像钱钟书所说的:”如果你爱一个人，那就带她去旅行吧”,而且是一次说走就走的旅行,其实我跟她说了是有准备攻略的,就是让她安心。事情发生在今年神圣的祖国的生日的第二天,她从广州飞往西宁,我从北京飞往西宁,我们在西宁会合,她比我提前一个小时到达,不知道是她知道我是那趟航班还是。。。我的飞机刚着地滑行几分钟,我就接到她打给我的电话,问我是否到了。我说:”到了,待会见啊”。我高兴的下飞机,恨不得立刻出现在她面前,吓她下,哈哈.. 到了西宁我们赶紧乘坐去西宁火车站的机场大巴,因为离火车发车还有2个小时,时间比较紧。。。。。她在中途跟我说,这地方确实比较贫穷,山上树都不长,而且气候都很干燥,根本没有田地。庆幸自己没出身在这,不然皮肤很不好。她又说:”有点困了,想睡觉”。我说:”你睡吧!!!”。我得说说那个大巴司机了,人生地不熟的我们,到哪下也不告诉我们,差点就在中途下车了。大概行驶了1个多小时,到了西宁火车站,当时的天已经变黑了,但是还是有点亮度,就是日落不久的那种","tags":[{"name":"情感","slug":"情感","permalink":"ly2513.github.com/tags/情感/"}]},{"title":"她(二️)","date":"2016-10-10T13:26:36.000Z","path":"2016/10/10/她(二)/","text":"2016年2月11日一个兴奋的日子,这天是农历正月初五,是我认识她以来第一次去她家拜年。那天我依稀记得我买了很多礼品,这是我们这边的习俗,去的别人家不能空手去,还必须带足的礼品才像样。前一天她跟我说:”你明天来我家,你得提前跟我说,不然我还没起床哦”。为了能让她多睡睡,我到了也没跟她说,直到她妈把她叫起,说:”李勇来了,你还在不起床啊”。 不久,她从她家楼上下来,跟我说:”你咋不提前跟我说,搞得还让我妈来叫”。我告诉她没有提前叫她的原因,还好她没生我气。。。。那天她家来了好多亲朋好友,搞得我有点不好意思,毕竟是第一次去她家,有点紧张。。。过年期间每家都很热闹,她家今天格外的热闹(自我感觉啊)。。。过年的情景就是,她家的亲朋好友聚在一起一边吃着过年的食物一边聊天。。。很快就到中午了,大家接下来就坐在一起吃饭了,她把她外公外婆叫过一起吃饭,我记得当时的情景是她用双手一边搀着外公一边搀着外婆,他们三人的脸上洋溢着🌞般的笑容,和谐至极。我跟她外公外婆并不陌生,之前有些接触,她外公和蔼,性格爽快,关键对我很好。。。还有一点就是她外公酒量惊人,排行榜首(厉害。。)。吃饭的时候她爸就坐我旁边,她爸说过的一句话到现在我还记得,他说:”李勇,你这小伙我满意,我就直说了吧,我对你没什么过多的要求,但你要在县城买套房子,你家先付个首付,如果首付钱还不够我借你点凑足付首付的钱。。。”,听完这句话我不知道说什么,因为我跟她爸这是第一次见面,她爸就直接进入话题了,说道房子是应该要买套,毕竟我也不希望我和她结婚后没有一个新家。我当时就点着头:”嗯。。”她爸妈对我的映像都还不错,我心里很高兴(偷着乐着了。。嘿嘿。。)饭桌上我和她家人聊得还好,都是一群性格直爽的人,没有太多的规矩,她爸妈都很客气。。。特别是她外公,他真心希望我俩好好的在一起生活,特别看好我俩。。那晚,我和她还有我姐、我姐夫、她哥、她嫂子、她弟一起去县城看电影《美人鱼》也是第一次和她看电影。看完电影我们还去吃了夜宵。。之后就回家了。。。第二天,我说服她去我家玩玩,也就是这天,不愉快的事情出来了。。。。。我们从她家出发,到县城的时候,我带她去我舅那拜年,我顺便在这说下,我舅在安城那边开了家超市–世纪华联,欢迎安福的亲朋好友前去购物。。。之后就坐车去我家了,同行的还有她姐、她哥(我姐夫)、她嫂子(我姐),我父母还有我奶奶都喜欢她。。。。她特别有气质,我没说谎话啊,我说真的。待续。。。。","tags":[{"name":"情感","slug":"情感","permalink":"ly2513.github.com/tags/情感/"}]},{"title":"PHP中使用cURL实现Get和Post请求的方法","date":"2016-05-04T14:42:49.000Z","path":"2016/05/04/PHP中使用cURL实现Get和Post请求的方法/","text":"今天主要讲下cURL，cURL是什么了？cURL有什么作用了？它在PHP中又是怎么运用的了？这些问题，都将在本博客中一一为你解惑。 问题一 cURL是什么 curl是利用URL语法在命令行方式下工作的开源文件传输工具，它支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持cURL库。 问题二 PHP中又是怎么运用cURL cURL可以使用URL的语法模拟浏览器来传输数据，因为它是模拟浏览器，因此它同样支持多种协议，FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP等协议都可以很好的支持，包括一些：HTTPS认证，HTTP POST方法，HTTP PUT方法，FTP上传，keyberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断点续传，上传文件断点续传，http代理服务器管道，甚至它还支持IPv6，scoket5代理服务器，通过http代理服务器上传文件到FTP服务器等等。这就是我们为什么要使用cURL的原因！使用cURL完成简单的请求主要分为以下四步： 1.初始化，创建一个新cURL资源 2.设置URL和相应的选项 3.抓取URL并把它传递给浏览器 4.关闭cURL资源，并且释放系统资源 我们来采集一个页面，通常情况下，我们会使用file_get_contents()函数来获取： 像这样：123456789&lt;?php $str = file_get_contents('http://bbs.baidu.net'); //或者是： $str = file(\"http://bbs.baidu.net\"); //或者是： readfile(\"http://bbs.baidu.net\"); ?&gt; 这样我们会发现，我们没有办法有效地进行错误处理，更重要的是我们没有办法完成一些高难度的任务： 如：处理cookies，验证，表单提交，文件上传等等。 好，现在我们来用代码完成上述cURL的四步：123456789101112// get方式实现// 1.初始化，创建一个新cURL资源$ch = curl_init();// 2.设置URL和相应的选项curl_setopt($ch, CURLOPT_URL, \"http://www.baidu.com/\");curl_setopt($ch, CURLOPT_HEADER, 0);// 3.抓取URL并把它传递给浏览器$output = curl_exec($ch);// 4.关闭cURL资源，并且释放系统资源curl_close($ch);// 打印获得的数据print_r($output); 以下是用POST方式实现12345678910111213141516171819202122&lt;?php // post方式 // 定义声明一个url $url = \"http://localhost/demoCurl.php\"; // 定义的post数据 $post_data = array (\"username\" =&gt; \"bob\",\"key\" =&gt; \"12345\"); // 1.初始化，创建一个新cURL资源 $ch = curl_init(); // 2.设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 设置post请求 curl_setopt($ch, CURLOPT_POST, 1); // 设置post的数据 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); // 3.抓取URL获得数据 $output = curl_exec($ch); // 4.关闭cURL资源，并且释放系统资源 curl_close($ch); // 打印获得的数据 print_r($output);?&gt; 上述四步中，其中第二步最为关键，可以设置一些高级选项： 选项 可选value值 备注 CURLOPT_AUTOREFERER 当根据Location:重定向时，自动设置header中的Referer:信息。 CURLOPT_BINARYTRANSFER 在启用CURLOPT_RETURNTRANSFER的时候，返回原生的（Raw）输出。 CURLOPT_COOKIESESSION 启用时curl会仅仅传递一个session cookie，忽略其他的cookie，默认状况下cURL会将所有的cookie返回给服务端。session cookie是指那些用来判断服务器端的session是否有效而存在的cookie。 CURLOPT_CRLF 启用时将Unix的换行符转换成回车换行符。 CURLOPT_DNS_USE_GLOBAL_CACHE 启用时会启用一个全局的DNS缓存，此项为线程安全的，并且默认启用。 CURLOPT_FAILONERROR 显示HTTP状态码，默认行为是忽略编号小于等于400的HTTP信息。 CURLOPT_FILETIME 启用时会尝试修改远程文档中的信息。结果信息会通过curl_getinfo()函数的CURLINFO_FILETIME选项返回。 curl_getinfo(). CURLOPT_FOLLOWLOCATION 启用时会将服务器服务器返回的”Location: “放在header中递归的返回给服务器，使用CURLOPT_MAXREDIRS可以限定递归返回的数量。 CURLOPT_FORBID_REUSE 在完成交互以后强迫断开连接，不能重用。 CURLOPT_FRESH_CONNECT 强制获取一个新的连接，替代缓存中的连接。 CURLOPT_FTP_USE_EPRT 启用时当FTP下载时，使用EPRT (或 LPRT)命令。设置为FALSE时禁用EPRT和LPRT，使用PORT命令 only. CURLOPT_FTP_USE_EPSV 启用时，在FTP传输过程中回复到PASV模式前首先尝试EPSV命令。设置为FALSE时禁用EPSV命令。 CURLOPT_FTPAPPEND 启用时追加写入文件而不是覆盖它。 CURLOPT_FTPASCII CURLOPT_TRANSFERTEXT的别名。 CURLOPT_FTPLISTONLY 启用时只列出FTP目录的名字。 CURLOPT_HEADER 启用时会将头文件的信息作为数据流输出。 CURLINFO_HEADER_OUT 启用时追踪句柄的请求字符串。 从 PHP 5.1.3 开始可用。CURLINFO_前缀是故意的(intentional)。 CURLOPT_HTTPGET 启用时会设置HTTP的method为GET，因为GET是默认是，所以只在被修改的情况下使用。 CURLOPT_HTTPPROXYTUNNEL 启用时会通过HTTP代理来传输。 CURLOPT_MUTE 启用时将cURL函数中所有修改过的参数恢复默认值。 CURLOPT_NETRC 在连接建立以后，访问~/.netrc文件获取用户名和密码信息连接远程站点。 CURLOPT_NOBODY 启用时将不对HTML中的BODY部分进行输出。 CURLOPT_NOPROGRESS 启用时关闭curl传输的进度条，此项的默认设置为启用。 Note: PHP自动地设置这个选项为TRUE，这个选项仅仅应当在以调试为目的时被改变。 CURLOPT_NOSIGNAL 启用时忽略所有的curl传递给php进行的信号。在SAPI多线程传输时此项被默认启用。 cURL 7.10时被加入。 CURLOPT_POST 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样。 CURLOPT_PUT 启用时允许HTTP发送文件，必须同时设置CURLOPT_INFILE和CURLOPT_INFILESIZE。 CURLOPT_RETURNTRANSFER 将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。 CURLOPT_SSL_VERIFYPEER 禁用后cURL将终止从服务端进行验证。使用CURLOPT_CAINFO选项设置证书使用CURLOPT_CAPATH选项设置证书目录 如果CURLOPT_SSL_VERIFYPEER(默认值为2)被启用，CURLOPT_SSL_VERIFYHOST需要被设置成TRUE否则设置为FALSE。 自cURL 7.10开始默认为TRUE。从cURL 7.10开始默认绑定安装。 CURLOPT_TRANSFERTEXT 启用后对FTP传输使用ASCII模式。对于LDAP，它检索纯文本信息而非HTML。在Windows系统上，系统不会把STDOUT设置成binary模式。 CURLOPT_UNRESTRICTED_AUTH 在使用CURLOPT_FOLLOWLOCATION产生的header中的多个locations中持续追加用户名和密码信息，即使域名已发生改变。 CURLOPT_UPLOAD 启用后允许文件上传。 CURLOPT_VERBOSE 启用时会汇报所有的信息，存放在STDERR或指定的CURLOPT_STDERR中。 对于下面的这些option的可选参数，value应该被设置一个integer类型的值： 选项 可选value值 备注 CURLOPT_BUFFERSIZE 每次获取的数据中读入缓存的大小，但是不保证这个值每次都会被填满。 在cURL 7.10中被加入。 CURLOPT_CLOSEPOLICY 不是CURLCLOSEPOLICY_LEAST_RECENTLY_USED就是CURLCLOSEPOLICYOLDEST，还存在另外三个CURLCLOSEPOLICY，但是cURL暂时还不支持。 CURLOPT_CONNECTTIMEOUT 在发起连接前等待的时间，如果设置为0，则无限等待。 CURLOPT_CONNECTTIMEOUT_MS 尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。 在cURL 7.16.2中被加入。从PHP 5.2.3开始可用。 CURLOPT_DNS_CACHE_TIMEOUT 设置在内存中保存DNS信息的时间，默认为120秒。 CURLOPT_FTPSSLAUTH FTP验证方式：CURLFTPAUTH_SSL (首先尝试SSL)，CURLFTPAUTH_TLS (首先尝试TLS)或CURLFTPAUTH_DEFAULT (让cURL自动决定)。 在cURL 7.12.2中被加入。 CURLOPT_HTTP_VERSION CURL_HTTP_VERSION_NONE (默认值，让cURL自己判断使用哪个版本)，CURL_HTTP_VERSION_1_0 (强制使用 HTTP/1.0)或CURL_HTTP_VERSION_1_1 (强制使用 HTTP/1.1)。 CURLOPT_HTTPAUTH 使用的HTTP验证方法，可选的值有：CURLAUTH_BASIC、CURLAUTH_DIGEST、CURLAUTH_GSSNEGOTIATE、CURLAUTH_NTLM、CURLAUTH_ANY和CURLAUTH_ANYSAFE。 可以使用位域(或)操作符分隔多个值，cURL让服务器选择一个支持最好的值。 CURLAUTH_ANY等价于CURLAUTH_BASIC 或 CURLAUTH_DIGEST 或 CURLAUTH_GSSNEGOTIATE 或 CURLAUTH_NTLM. CURLAUTH_ANYSAFE等价于CURLAUTH_DIGEST 或 CURLAUTH_GSSNEGOTIATE 或 CURLAUTH_NTLM. CURLOPT_INFILESIZE 设定上传文件的大小限制，字节(byte)为单位。 CURLOPT_LOW_SPEED_LIMIT 当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。 CURLOPT_LOW_SPEED_TIME 当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。 CURLOPT_MAXCONNECTS 允许的最大连接数量，超过是会通过CURLOPT_CLOSEPOLICY决定应该停止哪些连接。 CURLOPT_MAXREDIRS 指定最多的HTTP重定向的数量，这个选项是和CURLOPT_FOLLOWLOCATION一起使用的。 CURLOPT_PORT 用来指定连接端口。（可选项） CURLOPT_PROTOCOLS CURLPROTO_*的位域指。如果被启用，位域值会限定libcurl在传输过程中有哪些可使用的协议。这将允许你在编译libcurl时支持众多协议，但是限制只是用它们中被允许使用的一个子集。默认libcurl将会使用全部它支持的协议。参见CURLOPT_REDIR_PROTOCOLS. 可用的协议选项为：CURLPROTO_HTTP、CURLPROTO_HTTPS、CURLPROTO_FTP、CURLPROTO_FTPS、CURLPROTO_SCP、CURLPROTO_SFTP、CURLPROTO_TELNET、CURLPROTO_LDAP、CURLPROTO_LDAPS、CURLPROTO_DICT、CURLPROTO_FILE、CURLPROTO_TFTP、CURLPROTO_ALL 在cURL 7.19.4中被加入。 CURLOPT_PROXYAUTH HTTP代理连接的验证方式。使用在CURLOPT_HTTPAUTH中的位域标志来设置相应选项。对于代理验证只有CURLAUTH_BASIC和CURLAUTH_NTLM当前被支持。 在cURL 7.10.7中被加入。 CURLOPT_PROXYPORT 代理服务器的端口。端口也可以在CURLOPT_PROXY中进行设置。 CURLOPT_PROXYTYPE 不是CURLPROXY_HTTP (默认值) 就是CURLPROXY_SOCKS5。 在cURL 7.10中被加入。 CURLOPT_REDIR_PROTOCOLS CURLPROTO_*中的位域值。如果被启用，位域值将会限制传输线程在CURLOPT_FOLLOWLOCATION开启时跟随某个重定向时可使用的协议。这将使你对重定向时限制传输线程使用被允许的协议子集默认libcurl将会允许除FILE和SCP之外的全部协议。这个和7.19.4预发布版本种无条件地跟随所有支持的协议有一些不同。关于协议常量，请参照CURLOPT_PROTOCOLS。 在cURL 7.19.4中被加入。 CURLOPT_RESUME_FROM 在恢复传输时传递一个字节偏移量（用来断点续传）。 CURLOPT_SSL_VERIFYHOST 1 检查服务器SSL证书中是否存在一个公用名(common name)。译者注：公用名(Common Name)一般来讲就是填写你将要申请SSL证书的域名 (domain)或子域名(sub domain)。2 检查公用名是否存在，并且是否与提供的主机名匹配。 CURLOPT_SSLVERSION 使用的SSL版本(2 或 3)。默认情况下PHP会自己检测这个值，尽管有些情况下需要手动地进行设置。 CURLOPT_TIMECONDITION 如果在CURLOPT_TIMEVALUE指定的某个时间以后被编辑过，则使用CURL_TIMECOND_IFMODSINCE返回页面，如果没有被修改过，并且CURLOPT_HEADER为true，则返回一个”304 Not Modified”的header， CURLOPT_HEADER为false，则使用CURL_TIMECOND_IFUNMODSINCE，默认值为CURL_TIMECOND_IFUNMODSINCE。 CURLOPT_TIMEOUT 设置cURL允许执行的最长秒数。 CURLOPT_TIMEOUT_MS 设置cURL允许执行的最长毫秒数。 在cURL 7.16.2中被加入。从PHP 5.2.3起可使用。 CURLOPT_TIMEVALUE 设置一个CURLOPT_TIMECONDITION使用的时间戳，在默认状态下使用的是CURL_TIMECOND_IFMODSINCE。 对于下面的这些option的可选参数，value应该被设置一个string类型的值： 选项 可选value值 备注 CURLOPT_CAINFO 一个保存着1个或多个用来让服务端验证的证书的文件名。这个参数仅仅在和CURLOPT_SSL_VERIFYPEER一起使用时才有意义。 CURLOPT_CAPATH 一个保存着多个CA证书的目录。这个选项是和CURLOPT_SSL_VERIFYPEER一起使用的。 CURLOPT_COOKIE 设定HTTP请求中”Cookie: “部分的内容。多个cookie用分号分隔，分号后带一个空格(例如， “fruit=apple; colour=red”)。 CURLOPT_COOKIEFILE 包含cookie数据的文件名，cookie文件的格式可以是Netscape格式，或者只是纯HTTP头部信息存入文件。 CURLOPT_COOKIEJAR 连接结束后保存cookie信息的文件。 CURLOPT_CUSTOMREQUEST 使用一个自定义的请求信息来代替”GET”或”HEAD”作为HTTP请求。这对于执行”DELETE” 或者其他更隐蔽的HTTP请求。有效值如”GET”，”POST”，”CONNECT”等等。也就是说，不要在这里输入整个HTTP请求。例如输入”GET /index.html HTTP/1.0 “是不正确的。Note: 在确定服务器支持这个自定义请求的方法前不要使用。 CURLOPT_EGDSOCKET 类似CURLOPT_RANDOM_FILE，除了一个Entropy Gathering Daemon套接字。 CURLOPT_ENCODING HTTP请求头中”Accept-Encoding: “的值。支持的编码有”identity”，”deflate”和”gzip”。如果为空字符串””，请求头会发送所有支持的编码类型。 在cURL 7.10中被加入。 CURLOPT_FTPPORT 这个值将被用来获取供FTP”POST”指令所需要的IP地址。”POST”指令告诉远程服务器连接到我们指定的IP地址。这个字符串可以是纯文本的IP地址、主机名、一个网络接口名（UNIX下）或者只是一个’-‘来使用默认的IP地址。 CURLOPT_INTERFACE 网络发送接口名，可以是一个接口名、IP地址或者是一个主机名。 CURLOPT_KRB4LEVEL KRB4 (Kerberos 4) 安全级别。下面的任何值都是有效的(从低到高的顺序)：”clear”、”safe”、”confidential”、”private”.。如果字符串和这些都不匹配，将使用”private”。这个选项设置为NULL时将禁用KRB4 安全认证。目前KRB4 安全认证只能用于FTP传输。 CURLOPT_POSTFIELDS 全部数据使用HTTP协议中的”POST”操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似’para1=val1&amp;para2=val2&amp;…’或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data。 CURLOPT_PROXY HTTP代理通道。 CURLOPT_PROXYUSERPWD 一个用来连接到代理的”[username]:[password]”格式的字符串。 CURLOPT_RANDOM_FILE 一个被用来生成SSL随机数种子的文件名。 CURLOPT_RANGE 以”X-Y”的形式，其中X和Y都是可选项获取数据的范围，以字节计。HTTP传输线程也支持几个这样的重复项中间用逗号分隔如”X-Y,N-M”。 CURLOPT_REFERER 在HTTP请求头中”Referer: “的内容。 CURLOPT_SSL_CIPHER_LIST 一个SSL的加密算法列表。例如RC4-SHA和TLSv1都是可用的加密列表。 CURLOPT_SSLCERT 一个包含PEM格式证书的文件名。 CURLOPT_SSLCERTPASSWD 使用CURLOPT_SSLCERT证书需要的密码。 CURLOPT_SSLCERTTYPE 证书的类型。支持的格式有”PEM” (默认值), “DER”和”ENG”。 在cURL 7.9.3中被加入。 CURLOPT_SSLENGINE 用来在CURLOPT_SSLKEY中指定的SSL私钥的加密引擎变量。 CURLOPT_SSLENGINE_DEFAULT 用来做非对称加密操作的变量。 CURLOPT_SSLKEY 包含SSL私钥的文件名。 CURLOPT_SSLKEYPASSWD 在CURLOPT_SSLKEY中指定了的SSL私钥的密码。 Note: 由于这个选项包含了敏感的密码信息，记得保证这个PHP脚本的安全。 CURLOPT_SSLKEYTYPE CURLOPT_SSLKEY中规定的私钥的加密类型，支持的密钥类型为”PEM”(默认值)、”DER”和”ENG”。 CURLOPT_URL 需要获取的URL地址，也可以在curl_init()函数中设置。 CURLOPT_USERAGENT 在HTTP请求中包含一个”User-Agent: “头的字符串。 CURLOPT_USERPWD 传递一个连接中需要的用户名和密码，格式为：”[username]:[password]”。 对于下面的这些option的可选参数，value应该被设置为一个回调函数名： 选项 可选value值 CURLOPT_HEADERFUNCTION 设置一个回调函数，这个函数有两个参数，第一个是cURL的资源句柄，第二个是输出的header数据。header数据的输出必须依赖这个函数，返回已写入的数据大小。 CURLOPT_PASSWDFUNCTION 设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个密码提示符，第三个参数是密码长度允许的最大值。返回密码的值。 CURLOPT_PROGRESSFUNCTION 设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个文件描述符资源，第三个是长度。返回包含的数据。 CURLOPT_READFUNCTION 拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此函数，将自行处理返回的数据。返回值为数据大小，以字节计。返回0代表EOF信号。 CURLOPT_WRITEFUNCTION 拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此回调函数，将自行处理响应头信息。响应头信息是整个字符串。设置返回值为精确的已写入字符串长度。发生错误时传输线程终止。","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"}]},{"title":"前端组件库","date":"2016-04-27T08:39:21.000Z","path":"2016/04/27/前端组件库/","text":"搭建web app常用的样式/组件等收集列表(移动优先) 一个常用的PHP类库, 资源以及技巧列表 awesome-php 推荐 0. 前端自动化(Workflow) 前端构建工具 Webpack - module bundler Yeoman - a set of tools for automating development workflow gulp - The streaming build system grunt - the JavaScript Task Runner F.I.S - 前端集成解决方案 前端模块管理器 Bower - A package manager for the web Browserify Component Duo RequireJS Sea.js LABjs - 文件加载器 css-modulesify - CSS模块加载器 css预处理器 Less - Less is More , Than CSS Sass - Syntactically Awesome Style Sheets Stylus - Expressive, dynamic, robust CSS 前端性能分析工具 analyze-css - CSS 选择器的复杂度和性能分析器 1. 前端框架(Frameworks) Bootstrap Foundation Amaze UI Semantic UI Pure CSS topcoat UIkit Material UI Materialize - 一个基于 Material Design 的 CSS 框架 Framework7 mui ionic framework Fries jQuery Mobile App.js Office UI Fabric - 微软 Office 前端团队的框架 2. JavaScript 框架汇总 JavaScript 框架 react Angular jQuery Backbone.js ember.js Ractive.js KISSY Zepto.js Vanilla JS Vue.js - 数据驱动的组件化MVVM库(用于创建web交互界面和数据双向绑定) Can.js Avalon T3 JavaScript Framework - 一个用于搭建大型Web应用的客户端JS框架 jsblocks - Better MV-ish Framework 从简单 UI 到复杂单页应用都适用 轻量级JavaScript框架 Min.js - Super minimal selector and event library skel.js - A lightweight responsive framework Sprint.js - 一个高性能、小体积的 DOM 操作库 knockout PhantomJS - 一个基于 WebKit 的服务器端 JavaScript API 函数式反应型编程框架 FRP (Functional Reactive Programming) library Bacon.js - A small functional reactive programming lib for JavaScript. Flapjax - 一个支持FRP的JavaScript框架 JavaScript 工具库 underscore.js Underscore.string.js字符串操作库 functional.js Lo-Dash - A JavaScript utility library Lazy.js - a functional utility library for JavaScript Fn.js Way.js - 双向数据绑定库 boiler - a utility library that makes tasks in JavaScript easier 快捷键操作 Keys.js - 应用快捷键 simple-hotkeys jquery.hotkeys Mousetrap - 键盘快捷键操作 3. 前端游戏框架 cocos2d-html5 Egret Engine LimeJS EaselJS three.js AlloyStick The-Best-JS-Game-Framework CanvasEngine Quintus Stage.js phaser - 一个快速、免费、开源的 HTML5 游戏框架 4. ui组件库(CSS Framework) WeUI - 微信官方UI库 GMU - 基于zepto的ui组件库，适用于移动端 FrozenUI - 腾讯移动端组件库 NEC - 更好的CSS方案 NEJ - 更好的JS解决方案 Pure CSS Components magic-of-css Primer - The CSS toolkit and guidelines that power GitHub light7 - A Light and easy to use UI Lib Spectre.css - 轻量、响应式的现代 CSS 框架 5. 基础模版 浏览器统一(Cross Browser) HTML5 BOILERPLATE Modernizr Normalize.css HTML5 Shiv - 让ie浏览器成为支持html5的浏览器的解决方法 cssFx - 为CSS3自动生成浏览器前缀 -prefix-free - Break free from CSS prefix hell ieBetter.js - make ie browser like a morden browser main for ie6~ie8 es6-promise - Promise 对象的兼容 响应式 Responsive - 响应式布局 Enquire.js - Awesome Media Queries in JavaScript Free Wall - 创建桌面，移动和平板的动态网格布局 适配方案 MetaHandler.js：移动端适配各种屏幕无痛工具脚本 lib-flexible: 移动端自适应方案 参考: 使用Flexible实现手淘H5页面的终端适配 flexible demo 1 flexible demo 2 pageResponse responsive-page 6. 排版 yue.css typo.css chinese-copywriting-guidelines - 中文文案排版指南 7. 网格系统 grid Flexbox Grid MasonJS - creating a perfect grid 8. 路由和链接(Routing And URLs) History.js - gracefully supports the HTML5 History/State APIs jquery-pjax - pushState+ajax jquery-address - Deep Linking page.js - Micro client-side router crossroads.js hash.js path.js director.js - 前端路由库(通过#符号进行路径组织,结合vue的component可进行单页的局部模块刷新) URI.js Roadcrew.js SpeakingURL uparams - An URL params parser 9. UA 识别 detector 10. 表单处理10.1 表单验证(Form Validator)/表单提示 Validator Parsley jquery.form.js - jQuery Form Plugin Validform validator.js jquery-validation - jQuery Validation Plugin formvalidator.js Fort.js – 表单填写进度提示 mailcheck - 用于检测email地址的域名 Floatlable.js - 输入时显示placeholder文本 jQuery Label Better validator.js 10.2 &lt; select &gt; 相关 Chosen Select2 bootstrap-select 10.3 单选框/复选框相关 iCheck - 增强复选框和单选按钮 Switchery - iOS 7 style switches for your checkboxes 10.4 上传组件 jQuery File Upload Plugin 百度 Web Uploader uploadify Plupload Fine Uploader arale-upload - 轻量级 iframe and html5 file uploader Dropzone.js - 文件上传库(可获取文件mime, 文件大小等; 针对图片可生成缩略图,获取图片宽度,高度) flow.js localResizeIMG - 前端本地客户端压缩图片，兼容IOS，Android，PC simple-uploader 10.5 日期选择 Both Date and Time picker widget based on twitter bootstrap GMU 日历组件 Mobiscroll Pikaday - 日期选择器 PriceCalendar - 酒店价格日历 API文档 DEMO 10.6 取色 Colorpicker plugin for Twitter Bootstrap 10.7 标签插件(Tag) TaggingJS – 可以灵活定制的 jQuery 标签系统插件 selectize.js Bootstrap Tags Input 10.8 自动完成插件 At.js - 一个Twitter/微博样式的@自动完成插件 jquery-textcomplete - 智能搜索提示框/自动补全 typeahead.js - a fast and fully-featured autocomplete library 10.9 样式修正 autosize - 使文本框自动适应所输入的内容 11. 图表绘制/图形库(Graphics) Highcharts Chart.js - Simple HTML5 Charts using Canvas 百度 ECharts Chartist.js D3.js - A JavaScript visualization library for HTML and SVG. intro-to-d3 - a D3.js tutorial Bonsai - 一个功能强大的JavaScript图形库 epoch - 数据图表可视化 Vis.js Coutour.js zrender - 一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型，让canvas绘图大不同！ 12. 日期格式化 &amp; 时间轴 Moment.js - 日期处理 Smart Time Ago - 显示相对时间 timeline.js 13. 页面交互13.1 Slider slick - the last carousel you’ll ever need Swipe - the most accurate touch slider Swiper - Most modern mobile touch slider iscroll - Smooth scrolling for the web iSlider - 移动端滑动组件 OwlCarousel - create beautiful responsive carousel slider jquery-mousewheel - jQuery鼠标滚轮滚动侦测插件 Glide.js - 轻量级滑块组件 PhotoSwipe TouchSlide - 触屏滑动特效(焦点图,Tab切换) 13.2 瀑布流 Masonry Isotope - Filter &amp; sort magical layouts 13.3 懒加载/加载监听/预加载 imagesLoaded Echo.js lazySizes jquery_lazyload BttrLazyLoading lazyload.js layzr.js - 一个小巧快速的图片懒加载库 waitForImages - 图片加载监听库 PxLoader - JS预加载库:实现图片、声音等各种文件的预加载功能 bindWithDelay - jQuery Plugin For Delayed Event Execution TypeWatch - 停止输入时调用 13.4 图片轮播(幻灯片)/图片展示 FlexSlider unslider - 小而美的轮播库 prettyPhoto FlickerPlate - A cool jQuery plugin that lets you flick through content. Holder.js - Client-side image placeholders. RowGrid.js - 在径直的行里放置图片 ImageLightbox.js - 灯箱效果 JQuery Panorama Viewer - 全景视图 Intense Images - 全屏查看图片 Picturefill - 一个响应式图片 JS 插件 zoom.js - 一个 jQuery 图片放大插件 watermarkjs - 一个在浏览器中添加图片水印的 JS 库 responsive-images.js 13.5 图片剪裁/图片处理 Jcrop - Image Cropping Plugin for jQuery croppic - an image cropping jquery plugin smartcrop.js - 智能图片裁剪库 jQuery.eraser - 图像擦除插件 DD_belatedPNG.js - 让IE6支持透明PNG图片 FocusPoint.js 实现图片的响应式裁剪 imgareaselect CSSgram - CSS 实现的 Instagram 滤镜库 antimoderate - 图片模糊库 13.6 进度条/加载动画(Loading) NProgress.js progress.js Pace - Automatic page load progress bar jquery-ajax-progress nanobar - Very lightweight progress bars. waitMe - 很漂亮的loading效果 spin.js sonic.js fakeLoader.js loaders.css - 一个为性能优化的实现加载动画效果的 CSS 框架 css-loaders 13.7 侧滑插件(offcancas) pushy - a responsive off-canvas navigation menu Slideout.js - 一个用于移动 Web 应用的触摸滑出式导航菜单 13.8 菜单(Menu) SuperFish - 基于jQuery的级联下拉菜单 Responsive Nav - 响应式导航 13.9 滚动侦测(ScrollSpy) jquery-scrollspy(1) jquery-scrollspy(2) Waypoints ScrollMagic - 像进度条一样使用滚动条 13.10 滚动加载更多/下拉刷新(Pull to Refresh) jScroll web-pull-to-refresh pulltorefresh RubberBand.js - add pull-to-refresh functionality to any page. 13.11 平滑滚动插件(Smooth Scroll) jquery-smooth-scroll jquery.scrollTo - 平滑滚动到页面指定位置 smooth-scroll scrollUp elevator.js - 一个模拟电梯运行“返回顶部”的 JS 插件 13.12 全屏滚动/全屏切换 pagePiling.js - 全屏滚动效果 fullPage.js onepage-scroll zepto.fullpage - 专注于移动端的fullPage.js screenfull.js - 切换全屏模式 13.13 分屏滚动 multiscroll.js - 分屏滚动效果 13.14 转场效果 Animsition - 页面切换时的过渡效果 13.15 固定元素(Sticky) sticky - jQuery Plugin for Sticky Objects jquery.pin - 固定页面元素 stickUp Slinky.js - 堆叠头部创建滑动导航列表 13.16 触控事件 Hammer.js jquery.event.move.js 13.17 拖拽组件 Draggabilly - 专注于拖拽功能的 JS 库 dragula - 一个让拖放操作变简单的 JS 库 GridList - 可拖拉的响应式列表库 13.18 隐藏或展示页面元素 Headroom.js - 在不需要页头时将其隐藏 Readmore.js - 内容显示与隐藏插件 oriDomi - 像指一样折叠Dom元素 13.19 滚动条(Scrollbar) jScrollPane jquery.scrollbar perfect-scrollbar nanoScrollerJS tinyscrollbar 13.20 视差滚动(Parallax Scrolling) parallax.js jparallax skrollr 14. 代码高亮插件/代码编辑器 google-code-prettify highlight.js Rainbow ACE CodeMirror Crayon Syntax Highlighter prism - Lightweight, robust, elegant syntax highlighting. 15. UI Icon 组件 Font Awesome Glyphter: The SVG Font Machine Perfect Icons iconizr Cikonss - 纯CSS实现的响应式Icon Simple Icons 16. 动画(Animate) animate.css - A cross-browser library of CSS animations. Transit - CSS transitions and transformations for jQuery WOW - 在滚动过程中展示CSS动画效果(默认触发animate.css动画) AniJS - A Library to Raise your Web Design without Coding Move.js - 简化CSS3动画的JS库 ScrollMe – 在网页中加入各种滚动动画效果 Effeckt.css - A Performant Transitions and Animations Library NEC动画库 csshake - CSS classes to move your DOM magic - CSS3 Animations with special effects Hover.css - 很多鼠标Hover态的效果 SpinKit Velocity.js - 加速JavaScript动画 lenticular.js - 响应倾斜或鼠标事件创建图片动画 jQuery Interactive 3D - Create a 3D interactive object using images AnimateScroll - A Simple jQuery Plugin for Animating Scroll Blast.js - 把动画和样式注入到文本中 Bounce.js - 一个用于制作漂亮 CSS3 关键帧动画的 JS 库 Sticker.js - create a Sticker Effect scrollReveal.js - 元素进入可视区域自动触发设置好的动画 stroll.js - CSS3 list scroll effects jQuery Easing - 动画效果扩展 animations - CSS3 ANIMATION CHEAT SHEET iconate.js：将 icons 增加动画效果的 JS 库 17. 本地存储 cross-storage - Cross domain local storage localForage pouchdb basil.js Neurosync - JavaScript 本地离线 ORM 库 18. 模板引擎 mustache.js Handlebars.js artTemplate baiduTemplate JSRender EJS - JavaScript Templates Juicer - A Light Javascript Templete Engine. Tempo json2html Hogan.js - JavaScript templating from Twitter. Dust.js - Linkedin维护的项目 19. 通知组件/弹框组件/模态窗口 Notify.js(Web Notifications API) alertify.js AlertifyJS SweetAlert Messenger - 非常酷的弹框组件 PNotify Notify.js - A simple, versatile notification library Remodal - 模态窗口插件 action.js - 极简的tip和Modal弹窗效果 20. 提示控件(Tooltips) hint.css - 一款非常小巧的提示框效果 qTip2 - Pretty powerful tooltips tooltip - CSS Tooltips tooltipster - A jQuery tooltip plugin grumble.js - 气泡形状的提示（Tooltip）控件 Ouibounce - 离站提示控件 intro.js - 一个创建引导式网站介绍功能的 JS 库 data-tip.css - 纯 CSS 实现的工具提示 21. 对话框/遮罩层/弹出层(lightbox) fancyBox - Fancy jQuery lightbox jquery-lightbox - The popular lightbox script, ported to jQuery Colorbox - a jQuery lightbox artDialog - 经典的网页对话框组件 DialogEffects jQuery blockUI - Page or element overlay layer - web弹出窗/层 22. 文档/表格/PDF Backgrid.js - 强大的表格组件 handsontable - 在线可编辑excel表格 jQuery Bootgrid - 用于ajax生成动态表格 DataTables - Table plug-in for jQuery PDF.js - 一个 JavaScript 编写的 PDF 阅读器 jsPDF - Generate PDF files in JavaScript Recline.js - 灵活操作和展示数据 Dynatable - 交互式表格插件 fattable - 创建无限滚动无限行列数的表格 23. 目录树插件 zTree_v3 - jQuery Tree Plugin jstree - jQuery Tree Plugin fancytree - Tree plugin for jQuery 24. Ajax模块 fetch - A window.fetch JavaScript polyfill reqwest - browser asynchronous http requests ajax - Standalone AJAX library then-request browser-request superagent minAjax.js 25. 音频/视频 jPlayer - HTML5 Audio &amp; Video for jQuery video.js - HTML5 &amp; Flash video player Accessible HTML5 Video Player - PayPal 开源的 HTML5 视频播放器 Clappr - 开源的Web视频播放器 Plyr - A simple HTML5 media player FitVids.js - A lightweight, easy-to-use jQuery plugin for fluid width video embeds. BigVideo.js - The jQuery Plugin for Big Background Video BigScreen - A simple library for using the JavaScript Full Screen API Vide - 视频背景 winamp2-js Buzz - A Javascript HTML5 Audio library MediaElement.js 26. 按钮 Buttons - A CSS button library ButtonComponentMorph ProgressButtonStyles CreativeButtons CSS3 buttons jquery.onoff - Interactive, accessible toggle switches for the web. 27. 富文本编辑器/Markdown编辑器/Markdown解析器 Simditor - 简单快速的富文本编辑器 BachEditor - 一个有情怀的编辑器 TinyMCE bootstrap-markdown marked - markdown解析器 Markdown Plus Editor.md - 开源在线Markdown编辑器 stackedit Redactor Text Editor micromarkdown.js - 轻量级的md解析器 wangEditor - 支持移动端的轻量级web富文本框 28. 内容提取(Readability) Readability json.human.js - Json Formatting for Human Beings 29. 颜色(CSS Colors)/SVG/Canvas CSS Colours SVGeneration SVGMagic - 自动的创建PNG来兼容不支持SVG的浏览器 Adaptive Backgrounds - 从图片抽取主要颜色和应用到父元素 Seen.js - 渲染3D场景为SVG或者HTML Canvas 30. 选项卡(Tabs) Easy Responsive Tabs to Accordion Responsive-Tabs ion.tabs - jQuery tabs plugin jQuery-EasyTabs tabulous.js 31. 文本处理 ZeroClipboard - 文本复制插件 clipboard.js Bigfoot - 点击文章中的脚注弹窗显示 Annotator - 文本注解插件，可以包括注释、标签、用户等 Succinct - 用作截断多行文本,后面添加省略号 Flowtype.js - 自动调整字体大小和行号 flat-shadow FitText - A jQuery plugin for inflating web type shine.js - 实现漂亮阴影 Type Rendering Mix - 文本渲染引擎 jquery-expander - 阅读更多 Typed.js - 输入模拟插件 jQuery.dotdotdot - 多行文本溢出显示省略号 32. 布局(Layout) 分隔面板(Split Panel) split-pane jQuery UI Layout 33. 演示/幻灯片 reveal.js - The HTML Presentation Framework bespoke.js - DIY Presentation Micro-Framework impress.js shower deck.js 34. 国际化(i18n) jquery-i18n i18next.js jsperanto.js jed.js messageformat.js Polyglot.js 35. 邮件模板(Email Templates) responsive-html-email-template 36. 移动端优化(Optimizing Mobile Performance) FastClick - 处理移动端 click 事件 300 毫秒延迟 tappy jquery-fast-click 37. HTTP请求相关 pako - HTTP 请求正文压缩 参考阅读: 如何压缩 HTTP 请求正文 HTTP 请求正文压缩 DEMO RSA in JavaScript - 用RSA加密实现Web数据加密传输 38. 实用工具/其他插件 jquery-cookie InstantClick - 预加载用户可能会点击的一些链接 Async.js - 异步操作 html2canvas - 实现纯JS网页截图 jquery.qrcode.js - 生成二维码的 jQuery 插件 qrcodejs - JS生成QRCode的库 nakedpassword - 用脱衣女帮助检测密码强度 KityMinder - 脑图编辑工具 MixitUp - 动画过滤和排序 JQuery Tip Cards - 创建卡片交互的cards布局 Fallback.js - JavaScript library for dynamically loading CSS and JS files. swfobject prettyprint.js - An in-browser JavaScript variable dumper Shepherd - 为应用创建用户指南 RulersGuide.js - 类似PhotoShop标尺的js库 Gremlins.js - Monkey 测试库 RoughDraft.js - 简单快速的创建交互式的 HTML 模型的原型工具 favico.js - 动态改变浏览器标签栏中的网站图标 #设计模式( JavaScript Patterns ) javascript-patterns jquery-patterns - A variety of jQuery plugin patterns Learning JavaScript Design Patterns #在线工具( Online Tools ) jsbin - Collaborative JavaScript Debugging App jsbin@Github jsfiddle jsbeautifier - Online JavaScript beautifier resume.github.com 前端开发工具1. 开发工具 Sublime Text 2. 调试工具 Fiddler Weinre Rythem csscss - 用于检查css代码冗余 FECS - 基于 Node.js 的前端代码检查工具 3. 浏览器扩展(Chrome Extensions) Postman - REST Client Fiddler - Fiddler for Chrome Extension WEB前端助手(FeHelper) Web Developer Chrome Logger ColorZilla ColorPick Eyedropper Code Cola 1px AlloyDesigner - 前端重构开发辅助工具 Fontface Ninja PageSpeed Insights (by Google) HTTP Status Redirect Path Responsive Web Design Tester Window Resizer CSSViewer IE Tab Clear Cache JSONView Image Downloader Pretty Beautiful Javascript - 可以自动格式化混淆的js文件 JavaScript Errors Notifier CSS Diff - 在线比对页面上两个元素的CSS样式差异 WhatFont- 识别网页所使用的字体 前端参考集 frontend-guidelines - Some HTML, CSS and JS best practices. frontend-dev-bookmarks Codrops - Useful resources Front-end Code Standards &amp; Best Practices frontend-dev-bookmarks Airbnb 的 JavaScript 编码规范 awesome-javascript","tags":[{"name":"js","slug":"js","permalink":"ly2513.github.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"ly2513.github.com/tags/前端/"}]},{"title":" Git 添加空文件夹的方法","date":"2016-04-27T03:30:57.000Z","path":"2016/04/27/Git-添加空文件夹的方法/","text":"如果你想添加某个文件夹，但是想忽略其下的所有文件在空目录下创建.gitignore文件。 文件内写入如下代码，可以排除空目录下所有文件被跟踪：1234# Ignore everything in this directory*# Except this file!.gitignore","tags":[{"name":"git","slug":"git","permalink":"ly2513.github.com/tags/git/"}]},{"title":"Awesome PHP(PHP相关资料的收集汇总)","date":"2016-04-26T10:15:20.000Z","path":"2016/04/26/Awesome-PHP/","text":"Awesome PHP一个PHP资源列表，内容包括：库、框架、模板、安全、代码分析、日志、第三方库、配置工具、Web 工具、书籍、电子书、经典博文等等 贡献详细内容请查看贡献 和 代码管理. 目录 Awesome PHP 依赖管理 Dependency Management 其他的依赖管理 Dependency Management Extras 框架 Frameworks 其他框架 Framework Extras 框架组件 Components 微型框架 Micro Frameworks 其他微型框架 Micro Framework Extras 路由 Routers 模板 Templating 静态站点生成器 Static Site Generators 超文本传输协议 HTTP 爬虫 Scraping 中间件 Middlewares 网址 URL 电子邮件 Email 文件 Files 流 Streams 依赖注入 Dependency Injection 图像 Imagery 测试 Testing 持续集成 Continuous Integration 文档 Documentation 安全 Security 密码 Passwords 代码分析 Code Analysis Architectural Architectural 调试和分析 Debugging and Profiling 构建工具 Build Tools 任务运行器 Task Runners 导航 Navigation 资源管理 Asset Management 地理位置 Geolocation 日期和时间 Date and Time 事件 Event 日志 Logging 电子商务 E-commerce PDF PDF Office Office 数据库 Database 迁移 Migrations NoSQL NoSQL 队列 Queue 搜索 Search 命令行 Command Line 身份验证和授权 Authentication and Authorization 标记 Markup 字符串 Strings 数字 Numbers 过滤和验证 Filtering and Validation API API 缓存 Caching 数据结构和存储 Data Structure and Storage 通知 Notifications 部署 Deployment 国际化和本地化 Internationalisation and Localisation 第三方API Third Party APIs 扩展 Extensions 杂项 Miscellaneous 软件 Software PHP安装 PHP Installation 开发环境 Development Environment 虚拟机 Virtual Machines 集成开发环境(IDE) Integrated Development Environment Web应用 Web Applications 基础架构 Infrastructure 资源 Resources PHP网站 PHP Websites 其他网站 Other Websites PHP书籍 PHP Books 其他书籍 Other Books PHP视频 PHP Videos PHP阅读 PHP Reading PHP内核阅读 PHP Internals Reading PHP杂志 PHP Magazines 贡献 依赖管理 Dependency Management依赖和包管理库 Climb - 一个Composer版本管理工具 Composer Installers - 一个多框架Composer库安装器 Composer/Packagist - 一个包和依赖管理器 Melody - 一个用于构建Composer脚本文件的工具 Pickle - 一个PHP扩展安装器 其他的依赖管理 Dependency Management Extras其他的相关依赖管理 Composed - 一个在运行时解析你项目Composer环境的库 Composer Checker - 一个校验Composer配置的工具 Composer Merge Plugin - 一个用于合并多个composer.json文件的Composer插件 Composition - 一个在运行时检查Composer环境的库 NameSpacer - 一个转化下划线到命名空间的库 Patch Installer - 一个使用Composer安装补丁的库 Prestissimo - 一个开启并行安装进程的Composer插件 Satis - 一个静态Composer存储库的生成器 Toran Proxy - 一个静态Composer存储库和代理 框架 FrameworksWeb开发框架 Aura PHP - 一个独立的组件框架 CakePHP - 一个快速应用程序开发框架 (CP) Laravel 5 - 简洁优雅的PHP Web开发框架 (L5) Nette - 另一个由个体组件组成的框架 Phalcon - 通过C扩展实现的框架 PPI Framework 2 - 一个互操作性框架 Symfony 2 - 一个独立组件组成的框架 (SF2) Yii2 - 用于开发大型Web应用的高性能PHP框架 Zend Framework 2 - 另一个由独立组件组成的框架 (ZF2) Radar - 一个基于PHP的Action-Domain-Responder实现 Ice - 另一个通过C扩展实现的简单快速的PHP框架 Phalcon - 一个作为C扩展的框架 Yaf - 鸟哥的C扩展的框架 其他框架 Framework Extras其他Web开发框架 CakePHP CRUD - CakePHP的快速应用程序（RAD）插件 Knp RAD Bundle - Symfony 2的快速应用程序（RAD）包 Symfony CMF - 一个创建自定义CMS的内容管理框架 框架组件 Components来自web开发框架的独立组件 CakePHP Plugins - CakePHP插件的目录 Hoa Project - 另一个PHP组件包 League of Extraordinary Packages - 一个PHP软件开发组 Symfony2 Components - Symfony 2组件 Zend Framework 2 Components - Zend Framework 2组件 微型框架 Micro Frameworks微型框架和路由 Bullet PHP - 用于构建REST APIs的微型框架 Lumen - 一个Laravel的微型框架 Proton - 一个StackPHP兼容的微型框架 Silex - 基于Symfony2组件的微型框架 Slim - 另一个简单的微型框架 其他微型框架 Micro Framework Extras其他相关的微型框架和路由 Silex Skeleton - Silex的项目架构 Silex Web Profiler - 一个Silex web的调试工具 Slim Skeleton - Slim架构 Slim View - Slim自定义视图的集合 路由 Routers处理应用路由的库 Fast Route - 一个快速路由的库 Klein - 一个灵活的路由的库 Macaw - 一个简单的 PHP 路由器，超级精简、快速而且很性感。 Pux - 另一个快速路由的库 Route - 一个基于Fast Route的路由的库 模板 Templating模板化和词法分析的库和工具 Foil - 另一个原生PHP模板库 Lex - 一个轻量级模板解析器 MtHaml - 一个HAML模板语言的PHP实现 Mustache - 一个Mustache模板语言的PHP实现 Phly Mustache - 另一个Mustache模板语言的PHP实现 PHPTAL - 一个TAL模板语言的PHP实现 Plates - 一个原生PHP模板库 Smarty - 一个模板引擎 Twig - 一个全面的模板语言 Tale Jade - Jade模版语言的PHP实现 静态站点生成器 Static Site Generators用来生成web页面的预处理内容的工具 Couscous - 一个将Markdown转化为漂亮的网站的工具 Phrozn - 另一个转换Textile，Markdown和Twig为HTML的工具 Sculpin - 转换Markdown和Twig为静态HTML的工具 Spress - 一个能够将Markdown和Twig转化为HTML的可扩展工具 超文本传输协议 HTTP用于HTTP的库 Buzz - 另一个HTTP客户端 Guzzle - 一个全面的HTTP客户端 HTTPFul - 一个链式HTTP库 PHP VCR - 一个录制和重放HTTP请求的库 php-curl-class - PHP的Curl类 Requests - 一个简单的HTTP库 Retrofit - 一个能轻松创建REST API客户端的库 Zend-diactoros - PSR-7 HTTP消息实现 网址 URL解析URL的库 PHP Domain Parser - 一个本地前缀解析库 Purl - 一个URL处理库 Sabre/uri - 一个URI操作库 Uri - 另一个URL处理库 电子邮件 Email发送和解析邮件的库 CssToInlineStyles - 一个在邮件模板中的内联CSS库 Email Reply Parser - 一个邮件回复解析的库 Email Validator - 一个较小的电子邮件验证库 Fetch - 一个IMAP库 Mautic - 邮件营销自动化 Nette Mail - 一个简单优雅的邮件发送模块 PHPMailer - 另一个邮件解决方案 Stampie - 一个邮件服务库，类似于SendGrid,PostMark,MailGun和Mandrill. SwiftMailer - 一个邮件解决方案 文件 Files文件处理和MIME类型检测的库 Apache MIME Types - 一个解析Apache MIME类型的库 Canal - 一个检测互联网媒体类型的库 CSV - 一个CSV数据处理库 Ferret - 一个MIME检测库 Flysystem - 另一个文件系统抽象层 Gaufrette - 一个文件系统抽象层 Hoa Mime - 另一个MIME检测库 Lurker - 一个资源跟踪库 PHP FFmpeg - 一个用于FFmpeg视频包装的库 PHP File Locator - 一个在大型项目中定位文件的库 流 Streams处理流的库 Streamer - 一个简单的面向对象的流包装库 依赖注入 Dependency Injection实现依赖注入设计模式的库 Acclimate - 一个依赖注入容器和服务定位的通用接口 Auryn - 一个递归的依赖注入容器 Container - 另一个可伸缩的依赖注入容器 PHP-DI - 一个支持自动装配和PHP配置的依赖注入容器 Pimple - 一个小的依赖注入容器 Symfony DI - 一个依赖注入容器组件 (SF2) 图像 Imagery处理图像的库 Color Extractor - 一个从图像中提取颜色的库 GIF Creator - 一个通过多张图片创建GIF动画的库 GIF Frame Extractor - 一个提取GIF动画帧信息的库 Glide - 一个按需处理图像的库 Imagine - 一个图像处理库 Image Hash - 一个用于生成图像哈希感知的库 Image Optimizer - 一个优化图像的库 Image With Text - 一个在图像中嵌入文本的库 Imagine - 一个图像处理库 Intervention Image - 另一个图像处理库 PHP Image Workshop - 另一个图像处理库 PHPThumb - 缩略图处理库 Phpqrcode - 二维码生成库 QrCode - 另一个二维码生成库 测试 Testing测试代码和生成测试数据的库 Alice - 富有表现力的一代库 AspectMock - 一个PHPUnit/Codeception的模拟框架。 Atoum - 一个简单的测试库 Behat - 一个行为驱动开发（BDD）测试框架 Codeception - 一个全栈测试框架 DBUnit - 一个PHPUnit的数据库测试库 Faker - 一个伪数据生成库 HTTP Mock - 一个在单元测试模拟HTTP请求的库 Kahlan - 全栈Unit/BDD测试框架，内置stub，mock和代码覆盖率的支持 Locust - 一个Python开发的现代负载测试库 Mink - Web验收测试 Mockery - 一个用于测试的模拟对象的库 ParaTest - 一个PHPUnit的并行测试库 Peridot - 一个事件驱动开发的测试框架 Phake - 另一个用于测试的模拟对象的库 Pho - 另一个行为驱动开发测试框架 PHPSpec - 一个基于功能点设计的单元测试库 PHPUnit - 一个单元测试框架 Prophecy - 一个可选度很高的模拟框架 Samsui - 另一个伪数据生成库 VFS Stream - 一个用于测试的虚拟文件系统流的包装器 VFS - 另一个用于测试虚拟的文件系统 持续集成 Continuous Integration持续集成的库和应用 GitlabCi - 使用GitLab CI测试、构建、部署你的代码，像TravisCI Jenkins - 一个PHP支持的持续集成平台 JoliCi - 一个用PHP编写的由Docker支持的持续集成的客户端 PHPCI - 一个PHP的开源的持续集成平台 SemaphoreCI - 一个开放源码和私人项目的持续集成平台 Shippable - 一个基于开源和私人项目持续集成平台的docker Sismo - 一个持续测试的服务库 Travis CI - 一个持续集成平台 Wercker - 一个持续集成平台 文档 Documentation生成项目文档的库 APIGen - 另一个API文档生成器 Daux.io - 一个使用Markdown文件的文档生成器 PHP Documentor 2 - 一个API文档生成器 PhpDox - 一个PHP项目的文档生成器（不限于API文档） Sami - 一个API文档生成器 安全 Security生成安全的随机数，加密数据，扫描漏洞的库 Halite - 一个简单的使用libsodium的加密库 HTML Purifier - 一个兼容标准的HTML过滤器 IniScan - 一个扫描PHP INI文件安全的库 jose - JSON签名和加密的库 Optimus - 基于Knuth乘法散列方法的身份混淆工具 PHP Encryption - 一个安全的PHP加密库 PHP IDS - 一个结构化的PHP安全层 PHP SSH - 一个试验的面向对象的SSH包装库 PHPSecLib - 一个纯PHP安全通信库 RandomLib - 一个生成随机数和字符串的库 SecurityMultiTool - 一个PHP安全库 SensioLabs Security Check - 一个为检查Composer依赖提供安全建议的web工具 TCrypto - 一个简单的键值加密存储库 True Random - 使用www.random.org生成随机数的库 VAddy - 一个持续安全的web应用测试平台 Zed - 一个集成的web应用渗透测试工具 密码 Passwords处理和存储密码的库和工具 GenPhrase - 一个随机生成安全密码哈希的库 Password Compat - 一个新的PHP5.5密码函数的兼容库 Password Policy - 一个PHP和JavaScript的密码策略库 Password Validator - 一个校验和升级密码哈希的库 Password-Generator - 一个生成随机密码的PHP库 PHP Password Lib - 一个生成和校验密码的库 phpass - 一个便携式的密码哈希框架 Zxcvbn PHP - 一个基于Zxcvbn JS的现实的PHP密码强度估计库 代码分析 Code Analysis分析，解析和处理代码库的库和工具 Athletic - 一个基于注释的基准检测库 Code Climate - 一个自动代码审查工具 Dissect - 一个词法和语法分析的工具集合 Exakat - 一个PHP的静态分析引擎 GrumPHP - 一个用来保护代码质量的Composer插件 Mondrian - 使用图论的代码分析工具 PHP Analyser - 一个分析PHP代码查找缺陷和错误的库 PHP Code Sniffer - 一个检测PHP、CSS和JS代码标准冲突的库 PHP CS Fixer - 一个编码标准库 PHP Manipulator - 一个分析和修改PHP源代码的库 PHP Mess Detector - 一个扫描代码缺陷，次优代码，未使用的参数等等的库。 PHP Metrics - 一个静态测量库 PHP Parser - 一个PHP编写的PHP解析器 PHP Refactoring Browser - 一个重构PHP代码的命令行工具集 PHP Semantic Versioning Checker - 一个比较两个源集和确定适当的应用语义版本的命令行实用程序 PHPCheckstyle - 一个帮助遵守特定的编码惯例的工具 PHPCPD - 一个检测复制和粘贴代码的库 PhpDependencyAnalysis - 一个创建可定制依赖图的工具 PHPLOC - 一个快速测量PHP项目大小的工具 PHPQA - 一个用于运行质量保证工具的工具(phploc, phpcpd, phpcs, pdepend, phpmd, phpmetrics). PHPPHP - 一个PHP实现的PHP虚拟机 PHPSandbox - 一个PHP沙盒环境 Scrutinizer - 一个审查PHP代码的web工具 UBench - 一个简单的微型基准检测库 Architectural Architectural相关的设计模式库，组织代码编程的方法和途径 Compose - 一个功能组合库 Design Patterns PHP - 一个使用PHP实现的设计模式存储库 Finite - 一个简单的PHP有限状态机 Functional PHP - 一个函数式编程库 Galapagos - 语言转换进化 Iter - 一个使用生成器提供迭代原语的库 Monad PHP - 一个简单Monad库 Patchwork - 一个重新定义用户的函数库 PHP Option - 一个可选的类型库 Pipeline - 一个管道模式的实现 Ruler - 一个简单的无状态的生产环境规则引擎 RulerZ - 一个强大的规则引擎和规范模式的实现 调试和分析 Debugging and Profiling调试和分析代码的库和工具 APM - 一个收集SQLite/MySQL/StatsD错误信息和统计信息的监控扩展 Barbushin PHP Console - 另一个使用Google Chrome的web调试控制台 Blackfire.io - 一个低开销的代码分析器 Kint - 一个调试和分析工具 PHP Console - 一个web调试控制台 PHP Debug Bar - 一个调试工具栏 PHPBench - 一个基准测试框架 PHPDBG - 一个交互的PHP调试器 PHP Console - Web调试控制台 Tideways.io - Monitoring and profiling tool Tracy - A一个简单的错误检测，写日志和时间测量库 xDebug - 一个调试和分析PHP的工具 XHProf - 一个最初由Facebook开发的分析工具 Z-Ray - 一个调试和配置Zend服务器的工具 构建工具 Build Tools项目构建和自动化工具 Bob - 一个简单的项目自动化工具 Box - 一个构建PHAR文件的工具 Go - 一个简单的PHP构建工具 Phake - 一个PHP克隆库 Phing - 一个灵感来自于Apache Ant的PHP项目构建系统 任务运行器 Task Runners自动运行任务的库 Bldr - 一个构建在Symfony组件上的PHP任务运行器 Jobby - 一个没有修改crontab的PHP定时任务管理器 Robo - 一个面向对象配置的PHP任务运行器 Task - 一个灵感来源于Grunt和Gulp的纯PHP任务运行器 导航 Navigation构建导航结构的工具 Cartographer - 一个站点地图生成库 KnpMenu - 一个菜单库 资源管理 Asset Management管理，压缩和最小化web站点资源的工具 Assetic - 一个资源管理的管道库 JShrink - 一个JavaScript的最小化库 Munee - 一个资源优化库 Pipe - 另一个资源管理的管道库 Puli - 一个检测资源绝对路径的库 地理位置 Geolocation地理编码地址和使用纬度经度的库 GeoCoder - 一个地理编码库 GeoJSON - 一个GeoJSON的实现 GeoTools - 一个地理工具相关的库 PHPGeo - 一个简单的地理库 日期和时间 Date and Time处理日期和时间的库 CalendR - 一个日历管理库 Carbon - 一个简单的日期时间API扩展 ExpressiveDate - 另一个日期时间API扩展 Moment.php - 灵感来源于Moment.js的PHP DateTime处理库，支持国际化 事件 Event时间驱动或实现非阻塞事件循环的库 Amp - 一个事件驱动的不阻塞的I/O库 Broadway - 一个事件源和CQRS(命令查询责任分离)库 Cake Event - 一个事件调度的库 (CP) Elephant.io - 另一个web socket库 Evenement - 一个事件调度的库 Event - 一个专注于域名事件的库 Hoa EventSource - 一个事件源库 Hoa WebSocket - 另一个web socket库 Icicle - 一个支持协同，非阻塞I/O，多线程的异步库 Prooph Event Store - 一个持久化事件消息的事件源组件 Ratchet - 一个web socket库 React - 一个事件驱动的非阻塞I/O库. Rx.PHP - 一个reactive扩展库 Workerman - 一个事件驱动的不阻塞的I/O库 日志 Logging生成和处理日志文件的库 Analog - 一个基于闭包的微型日志包 KLogger - 一个易用的兼容PSR-3的日志类 Monolog - 一个全面的日志工具 SeasLog - 一个高性能的PHP日志系统 电子商务 E-commerce处理支付和构建在线电子商务商店的库和应用 Money - 一个Fowler金钱模式的PHP实现 OmniPay - 一个框架混合了多网关支付处理的库 Payum - 一个支付抽象库 Sebastian Money - 另一个处理货币值的库 Shopware - 一个可高度定制的电子商务软件 Swap - 一个汇率库 Sylius - 一个开源的电子商务解决方案 Thelia - 另一个开源的电子商务解决方案 PDF PDF处理PDF文件的库和软件 Dompdf - 一个将HTML转换为PDF的工具 PHPPdf - 一个将XML文件转换为PDF和图片的库 Snappy - 一个PDF和图像生成器库 WKHTMLToPDF - 一个将HTML转换为PDF的工具 Office OfficeLibraries for working with office suite documents. ExcelAnt - 一个操作Excel文档的库 PHPExcel - 一个处理Excel文档的库 PHPPowerPoint - 一个处理PPT文档的库 PHPWord - 一个处理Word文档的库 数据库 Database使用对象关系映射（ORM）或数据映射技术的数据库交互的库 Baum - 一个Eloquent的嵌套集实现 Cake ORM - 对象关系映射工具，利用DataMapper模式实现 (CP) Doctrine Extensions - 一个Doctrine行为扩展的集合 Doctrine - 一个全面的DBAL和ORM Eloquent - 一个简单的ORM(L5) LazyRecord - 一个简单、可扩展、高性能的ORM Medoo - 一个轻量级的加速开发的ORM Pomm - 一个PostgreSQL对象模型管理器 Propel - 一个快速的ORM，迁移库和查询构架器 ProxyManager - 一个为数据映射生成代理对象的工具集 RedBean - 一个轻量级，低配置的ORM Spot2 - 一个MySQL的ORM映射器 迁移 Migrations帮助管理数据库模式和迁移的库 Doctrine Migrations - 一个Doctrine的迁移库 Migrations - 一个迁移管理库 Phinx - 另一个数据库迁移的管理库 PHPMig - 另一个迁移管理库 Ruckusing - 基于PHP下ActiveRecord的数据库迁移，支持MySQL, Postgres, SQLite NoSQL NoSQL处理NoSQL后端的库 Monga - 一个MongoDB抽象库 MongoQB - 一个MongoDB查询构建库 Mongo-php-library - MongoDB 官方PHP库 PHPMongo - 一个MongoDB ORM. Predis - 一个功能完整的Redis库 Phpredis - 另一个功能完整的Redis库 队列 Queue处理事件和任务队列的库 Bernard - 一个多后端抽象库 BunnyPHP - 一个高性能的纯PHP AMQP(RabbitMQ)同步和异步(ReactPHP)库 Gearman - 任务分发系统 Pheanstalk - 一个Beanstalkd客户端库 PHP AMQP - 一个纯PHP AMQP库 Php-resque - 基于redis的消息队列 RedisQueue - 一个基于redis的消息队列的、性能高、使用简单、文档齐全、易扩展的队列组件(推荐使用) Tarantool Queue - PHP绑定Tarantool队列 Thumper - 一个RabbitMQ模式库 搜索 Search在数据上索引和执行查询的库和软件 Elastica - ElasticSearch的客户端库 ElasticSearch PHP - ElasticSearch的官方客户端库 Solarium - Solr的客户端库 Sphinx Search - Sphinx搜索库，提供SphinxQL索引和搜索的功能 SphinxQL query builder - Sphinx搜索引擎的的查询库 命令行 Command Line关于命令行工具的库 Boris - 一个微型PHP REPL Cilex - 一个构建命令行工具的微型框架 CLI Menu - 一个构建CLI菜单的库 CLIFramework - 一个支持完全zsh／bash、子命令和选项约束的命令行框架，这也归功于phpbrew CLImate - 一个输出带颜色的和特殊格式的命令行库 Commando - 另一个简单的命令行选择解析器 Cron Expression - 一个计算cron运行日期的库 GetOpt - 一个命令行选择解析器 GetOptionKit - 另一个命令行选择解析器 Hoa Console - 另一个命令行库 OptParse - 另一个命令行选择解析器 Pecan - 一个事件驱动和非阻塞的shell PsySH - 另一个PHP REPL ShellWrap - -一个简单的命令行包装库 Shunt - 一个在多台远程机器上并行运行命令行的库 定时任务 Crontab 定时任务管理 crontab在 PHP 中的相关封装 Cronlingo - Express crontabs as human friendly phrases Dispatcher - 基于Laravel的定时任务管理 Jobby - 一个 PHP 的定时任务管理器 Swoole-crontab - 基于swoole的定时器程序，支持秒级处理 身份验证和授权 Authentication and Authorization实现身份验证和授权的库 EvaOAuth - 统一接口的 OAuth 登录 PHP 类库 Hawk - 一个Hawk HTTP身份认证库 HybridAuth - 一个开源的社交登陆库 Json Web Token - 使用JSON Tokens进行身份验证和信息传输 Lock - 一种实现访问控制列表（ACL）系统的库 OAuth 1.0 Client - 一个OAuth 1.0客户端的库 OAuth 2.0 Client - 一个OAuth 2.0客户端的库 OAuth2 Server - 另一个OAuth2服务器实现 OAuth2 Server - 另一个OAuth2服务器实现 Opauth - 一个多渠道的身份验证框架 PHP oAuthLib - 另一个OAuth库 Sentinel Social - 一个社交网络身份验证库 Sentinel - 一个混合的身份验证和授权的框架库 Sentry - 认证和授权系统 TwitterOAuth - 一个Twitter OAuth库 TwitterSDK - 一个完全测试的Twitter SDK 标记 Markup处理标记的库 Cebe Markdown - 一个快速的可扩展的Markdown解析器 Ciconia - 另一个支持Github Markdown风格的Markdown解析器 CommonMark PHP - 一个对CommonMark spec全支持的Markdown解析器 Decoda - 一个轻量级标记解析库 Emoji - 一个把Unicode字符和名称转换为表情符号图片的库 HTML to Markdown - 将HTML转化为Markdown HTML5 PHP - 一个HTML5解析和序列化库 Parsedown - 另一个Markdown解析器 PHP Markdown - 一个Markdown解析器 Php-emoji - 一个emoji表情转换库 字符串 Strings解析和处理字符串的库 Agent - 一个基于Mobiledetect的桌面／手机端user agent解析库 ANSI to HTML5 - 一个将ANSI转化为HTML5的库 Color Jizz - 处理和转换颜色的库 Device Detector - 另一个解析user agent字符串的库 Hoa String - 另一个UTF-8字符串库 Jieba-PHP - Python的jieba的PHP端口，自然语言处理的中文文本分词 Mobile-Detect - 一个用于检测移动设备的轻量级PHP类(包括平板电脑) Patchwork UTF-8 - 一个处理UTF-8字符串的便携库 Slugify - 转换字符串到slug的库 SQL Formatter - 一个格式化SQL语句的库 Stringy - 一个多字节支持的字符串处理库 Text - 一个文本处理库 UA Parser - 一个解析user agent字符串的库 URLify - 一个Django中URLify.js的PHP版本 UUID - 生成UUIDs的库 数字 Numbers处理数字的库 ByteUnits - 一个在二进制和度量系统中解析,格式化和转换字节单元的库 LibPhoneNumber for PHP - 一个Google电话号码处理的PHP实现库 Hashids.php - 用来把整数生成唯一字符串（比如：通过加密解密id来隐藏真实id) Math - 一个处理巨大数字的库 Numbers PHP - 一个处理数字的库 PHP Conversion - 另一个用于度量单位间转换的库 PHP Units of Measure - 一个计量单位转换的库 过滤和验证 Filtering and Validation过滤和验证数据的库 Cake Validation - 另一个验证库 (CP) DMS Filter - 一个注释过滤库 Filterus - 一个简单的PHP过滤库 ISO-codes - 一个验证各种ISO和ZIP编码的库(IBAN, SWIFT/BIC, BBAN, VAT, SSN, UKNIN) MetaYaml - 一个支持YAML,JSON和XML的模式验证库 Php-readability - 内容分析算法 Respect Validation - 一个简单的验证库 Upload - 一个处理文件上传和验证的库 Valitron - 另一个验证库 Volan - 另一个简单的验证库 REST和API开发REST-ful API的库和Web工具 API Platform - 暴露出REST API的项目，包含JSON-LD, Hydra格式 Apigility - 一个使用Zend Framework 2构建的API构建器 Drest - 一个将Doctrine实体暴露为REST资源节点的库 Fractal - [最佳实践]数据返回的统一化处理 HAL - 一个超文本应用语言(HAL)构建库 Hateoas - 一个HOATEOAS REST web服务库 Negotiation - 一个内容协商库 Restler - 一个将PHP方法暴露为RESTful web API的轻量级框架 Wsdl2phpgenerator - 一个从SOAP WSDL文件生成PHP类的工具 缓存 Caching缓存数据的库 Alternative PHP Cache (APC) - 打开PHP操作码缓存 APIx Cache - 一个轻量级的PSR-6缓存 CacheTool - 一个使用命令行清除apc/opcode缓存的工具 Cake Cache - 一个缓存库 (CP) Doctrine Cache - 一个缓存库 PhpFastCache - PHP 缓存库 Stash - 另一个缓存库 Zend Cache - 另一个缓存库 (ZF2) 数据结构和存储 Data Structure and Storage实现数据结构和存储技术的库 Ardent - 一个数据结构库 Cake Collection - 一个简单的集合库 (CP) Collections - 一个PHP的集合抽象库 Fractal - 一个转换复杂数据结构到JSON输出的库 Ginq - 另一个基于.NET实现的PHP的LINQ库 JsonMapper - 一个将内嵌JSON结构映射为PHP类的库 PHP Collections - 一个简单的集合库 PINQ - 一个基于.NET实现的PHP的LINQ(Language Integrated Query)库 Serializer - 一个序列化和反序列化数据的库 Totem - -一个管理和创建数据交换集的库 YaLinqo - 另一个PHP的LINQ库 Zend Serializer - 另一个序列化和反序列化数据的库 (ZF2) 通知 Notifications处理通知软件的库 JoliNotif - 一个跨平台的桌面通知库(支持Growl, notify-send, toaster等) Nod - 一个通知库(Growl等) Notification Pusher - 一个设备推送通知的独立库 Notificato - 一个处理推送通知的库 Notificator - 一个轻量级的通知库 Php-pushwoosh - 一个使用Pushwoosh REST Web服务轻松推送通知的PHP库 部署 Deployment项目部署库 Deployer - 一个部署工具 Envoy - 一个用PHP运行SSH任务的工具 Plum - 一个部署库 Pomander - 一个PHP应用部署工具 Rocketeer - PHP世界里的一个快速简单的部署器 Walle-web - 一个开源的web代码发布管理系统 国际化和本地化 Internationalisation and Localisation国际化(I18n)和本地化(L10n)的库 Aura Intl Cake I18n - 消息国际化和日期和数字的本地化 (CP) 第三方API Third Party APIs访问第三方API的库 Amazon Web Service SDK - PHP AWS SDK官方库 Campaign Monitor - Campaign Monitor官方PHP库 Digital Ocean - Digital Ocean API接口库 Dropbox SDK - Dropbox SDK官方PHP库 Github - 一个Github API交互库 PHP Github API - 另一个Github API交互库 S3 Stream Wrapper - Amazon S3流包装库 Stripe - Stripe官方PHP库 Twilio - Twilio官方PHP REST API Twitter OAuth - 一个Twitter OAuth工作流交互库 Twitter REST - 一个Twitter REST API交互库 扩展 Extensions帮助构建PHP扩展的库 PHP CPP - 一个开发PHP扩展的C++库 Zephir - 用于开发PHP扩展，且介于PHP和C++之间的编译语言 杂项 Miscellaneous创建一个开发环境的软件 Annotations - 一个注释库(Doctrine的一部分) Cake Utility - 工具类如Inflector，字符串，哈希，安全和XML (CP) Chief - 一个命令总线库 ClassPreloader - 一个优化自动加载的库 Country List - 所有带有名称和ISO 3166-1编码的国家列表 Embera - 一个Oembed消费库 Essence - 一个用于提取网络媒体的库 Flux - 一个正则表达式构建库 Graphviz - 一个图形库 Hprose-PHP - 一个很牛的RPC库，现在支持25+种语言 JSON Lint - 一个JSON lint工具 JSONPCallbackValidator - 验证JSONP回调的库 Jumper - 一个远程服务执行库 LadyBug - 一个dumper库 Lambda PHP - 一个PHP中的Lambda计算解析器 LiteCQRS - 一个CQRS(命令查询责任分离)库 Metrics - 一个简单的度量API库 Nmap - 一个Nmap PHP包装器 Opengraph - 一个开放图库 Pagerfanta - 一个分页库 PHP Expression - 一个PHP表达式语言 PHP PassBook - 一个iOS PassBook PHP库 PHP-GPIO - 一个用于Raspberry PI的GPIO pin的库 PHPCR - 一个Java内容存储库(JCR)的PHP实现 PHPStack - 一个PHP编写的TCP/IP栈概念 print_o - 一个对象图的可视化器 Procrastinator - 一个运行耗时任务的库 Prooph Service Bus - 轻量级的消息总线，支持CQRS和微服务 RMT - 一个编写版本和发布软件的库 sabre/vobject - 一个解析VCard和iCalendar对象的库 Slimdump - 一个简单的MySQL dumper工具 Spork - 一个处理forking的库 Sslurp - 一个使得SSL处理减少的库 SuperClosure - 一个允许闭包序列化的库 Symfony VarDumper - 一个dumper库(SF2) Underscore - 一个Undersccore JS库的PHP实现 Whoops - 一个不错的错误处理库 PHP安装 PHP Installation在你的电脑上帮助安装和管理PHP的工具 HomeBrew PHP - 一个HomeBrew的PHP通道 HomeBrew - 一个OSX包管理器 PHP Brew - 一个PHP版本管理和安装器 PHP Build - 另一个PHP版本安装器 PHP Env - 另一个PHP版本管理器 PHP OSX - 一个OSX下的PHP安装器 PHP Switch - 另一个PHP版本管理器 VirtPHP - 一个创建和管理独立PHP环境的工具 开发环境 Development Environment创建沙盒开发环境的软件和工具 Ansible - 一个非常简单的编制框架 Phansible - 一个用Ansible构建PHP开发虚拟机的web工具 Protobox - 另一个构建PHP开发虚拟机的web工具 PuPHPet - 一个构建PHP开发虚拟机的web工具 Puppet - 一个服务器自动化框架和应用 Vagrant - 一个便携的开发环境工具 虚拟机 Virtual Machines相关的PHP虚拟机 Hack - 一个PHP进行无缝操作的HHVM编程语言 HHVM - Facebook出品的PHP虚拟机，Runtime和JIT HippyVM - 另一个PHP虚拟机 集成开发环境(IDE) Integrated Development Environment支持PHP的集成开发环境 Eclipse for PHP Developers - 一个基于Eclipse平台的PHP IDE Netbeans - 一个支持PHP和HTML5的IDE PhpStorm - 一个商业PHP IDE Web应用 Web Applications基于Web的应用和工具 3V4L - 一个在线的PHP和HHVM shell Adminer - 一个数据库管理工具 Cachet - 开源状态页面系统 DBV - 一个数据库版本控制应用 Grav - 一个现代的flat－file的CMS MailCatcher - 一个抓取和查看邮件的web工具 PHP Queue - A一个管理后端队列的应用 PhpRedisAdmin - 一个用于管理Redis数据库的简单web界面 PhpPgAdmin - 一个PostgreSQL的web管理工具 PhpMyAdmin - 一个MySQL/MariaDB的web界面 rockmongo - MongoDB管理工具 基础架构 Infrastructure提供PHP应用和服务的基础架构 appserver.io - 一个用PHP写的多线程的PHP应用服务器 php-pm - 一个PHP应用的进程管理器、修改器和负载平衡器 PHP网站 PHP WebsitesPHP相关的有用的网站 Nomad PHP - 一个在线PHP学习资源 PHP Best Practices - 一个PHP最佳实践指南 PHP FIG - PHP框架交互组 PHP Mentoring - 点对点PHP导师组织 PHP School - 学习PHP的开源资源 PHP Security - 一个PHP安全指南 PHP The Right Way - 一个PHP最佳实践的快速指引手册 PHP UG - 一个帮助用户定位最近的PHP用户组(UG)的网站 PHP Versions - 哪些版本的PHP可以用在哪几种流行的Web主机上的列表 PHP Weekly - 一个PHP新闻周刊 PHPTrends - 一个快速增长的PHP类库的概述 Securing PHP - 一个关于PHP安全和库的建议的简报 Seven PHP - 一个PHP社区成员采访的网站 其他网站 Other Websitesweb开发相关的有用网站 Atlassian Git Tutorials - 一个Git教程系列 Hg Init - 一个Mercurial教程系列 Semantic Versioning - 一个解析语义版本的网站 Servers for Hackers - 一个关于服务器管理的新闻通讯 The Open Web Application Security Project (OWASP) - 一个开放软件安全社区 WebSec IO - 一个web安全社区资源 PHP书籍 PHP BooksPHP相关的非常好的书籍 Functional Programming in PHP - 这本书将告诉你如何利用PHP5.3+的新功能的认识函数式编程的原则 Grumpy PHPUnit - 一本Chris Hartjes关于使用PHPUnit进行单元测试的书 Mastering Object-Orientated PHP - 一本Brandon Savage关于PHP面向对象的书 Modern PHP New Features and Good Practices - 一本Josh Lockhart关于新的PHP功能和最佳做法的书 Modernising Legacy Applications in PHP - 一本Paul M.Jones关于遗留PHP应用进行现代化的书 PHP 7 Upgrade Guide - 一本Colin O’Dell的包含所有PHP 7功能和改变的书 PHP Pandas - 一本Dayle Rees关于如何学习写PHP的书 Scaling PHP Applications - 一本Steve Corona关于扩展PHP应用程序的电子书 Securing PHP: Core Concepts - 一本Chris Cornutt关于PHP常见安全条款和实践的书 Signaling PHP - 一本Cal Evans关于在CLI脚本捕获PCNTL信号的书 The Grumpy Programmer’s Guide to Building Testable PHP Applications - 一本Chris Hartjes关于构建PHP应用程序测试的书 XML Parsing with PHP - 这本书涵盖的解析和验证XML文档，利用XPath表达式，使用命名空间，以及如何创建和修改XML文件的编程 其他书籍 Other Books与一般计算和web开发相关的书 Elasticsearch: The Definitive Guide - Clinton Cormley和Zachary Tong编写的与Elasticsearch工作的一本指南 Eloquent JavaScript - Marijin Haverbeke关于JavaScript编程的一本书 Head First Design Patterns - 解说软件设计模式的一本书 Pro Git - Scott Chacon和Ben Straub关于Git的一本书 The Linux Command Line - William Shotts关于Linux命令行的一本书 The Tangled Web — Securing Web Applications - Michal Zalewski关于web应用安全的一本书 Understanding Computation - Tom Stuart关于计算理论的一本书 Vagrant Cookbook - Erika Heidi关于创建 Vagrant环境的一本书 PHP视频 PHP VideosPHP相关的非常不错的视频 PHP Town Hall - 一个随意的Ben Edmunds和Phil Sturgeon的PHP播客 PHP UK Conference - 一个PHP英国会议的视频集合 Programming with Anthony - Anthony Ferrara的视频系列 Taking PHP Seriously - 来自Facebook Keith Adams 讲述PHP优势 PHP阅读 PHP ReadingPHP相关的阅读资料 Composer Primer - Composer初级使用 Composer Stability Flags - 一篇关于Composer稳定性标志的文章 Composer Versioning - 一篇关于Composer版本的文章 Create Your Own PHP Framework - 一部Fabien Potencier的关于如何创建你自己的PHP框架的系列文章 Don’t Worry About BREACH - 一篇关于BREACH攻击和CSRF令牌的文章 On PHP 5.3, Lambda Functions and Closures - 一篇关于lambda函数和闭包的文章 PHP Is Much Better Than You Think - 一篇关于PHP语言和生态圈的文章 PHP Package Checklist - A checklist for successful PHP package development. PHP Sucks! But I Like It! - 一篇关于PHP利弊的文章 Preventing CSRF Attacks - 一篇阻止CSRF攻击的文章 Seven Ways to Screw Up BCrypt - 一篇关于纠正BCrypt实现的文章 Use Env - 一篇关于使用unix环境帮助的文章 PHP内核阅读 PHP Internals Reading阅读PHP内核或性能相关的资料 Disproving the Single Quotes Myth - 一篇关于单，双引号字符串性能的文章 How Big Are PHP Arrays (And Values) Really? - 一篇关于数组原理的文章 How Foreach Works - StackOverflow关于foreach回答的详情 How Long is a Piece of String - 一篇关于字符串原理的文章 PHP Evaluation Order - 一篇关于PHP评估顺序的文章 PHP Internals Book - 一本由三名核心开发编写的关于PHP内核的在线书 PHP RFCs - PHP RFCs主页(请求注解) Print vs Echo, Which One is Faster? - 一篇关于打印和echo性能的文章 The PHP Ternary Operator. Fast or Not? - 一篇关于三元操作性能的文章 Understanding OpCodes - 一篇关于opcodes的文章 When Does Foreach Copy? - 一篇关于foreach原理的文章 Why Objects (Usually) Use Less Memory Than Arrays - 一篇关于对象和数组原理的文章 You’re Being Lied To - 一篇关于内核ZVALs的文章 PHP杂志 PHP Magazines有趣的PHP相关的杂志 php[architect] - 一个致力于PHP的月更的杂志 本博客参考以下资料整理– awesome-php","tags":[{"name":"php","slug":"php","permalink":"ly2513.github.com/tags/php/"}]},{"title":"如何配置nodejs nginx的反向代理","date":"2016-04-25T09:44:17.000Z","path":"2016/04/25/如何配置nodejs-nginx的反向代理/","text":"本篇博客主要介绍在linux下配置nodejs在nginx下的反向代理 1、首先应安装nodejs,在此就不做介绍，自己可以用程序猿的方法去完成 2、安装nginx,我采用的是源码安装，这里也不做介绍 3、进入到/usr/local/nginx/conf目录（这里以你们自己的nginx的实际配置目录为主）在该目录下创建include 文件下，我的配置文件就写在这个文件夹里面 4、进入/usr/local/nginx/conf/include 目录，创建 nginx.node.conf 文件，在里面输入如下代码： 12345678910111213141516171819upstream nodejs &#123; server 127.0.0.1:3000; #server 127.0.0.1:3001; keepalive 64;&#125;server &#123; listen 80; server_name www.demoweb.com demoweb.com; access_log /var/log/nginx/test.log; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection \"\"; proxy_pass http://nodejs; &#125;&#125; 5、进入/usr/local/nginx/conf ，打开nginx.conf, 在http 里面添加 include /usr/local/nginx/conf/include/* 6、重启nginx , 输入 /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 7、在浏览器输入demoweb.com 就好了.","tags":[{"name":"nginx","slug":"nginx","permalink":"ly2513.github.com/tags/nginx/"},{"name":"nodejs","slug":"nodejs","permalink":"ly2513.github.com/tags/nodejs/"}]},{"title":"她(一)","date":"2016-04-21T13:27:08.000Z","path":"2016/04/21/她/","text":"2015年10月03日–一个很重要的日子，对于我来说是个很重要的日子，因为我和她这天相遇了。当时我并不知道这女孩后来会占据了我的心，而且对我影响很大。我和她相遇是在我们的那个县城–安福，顺便介绍下安福吧，安福寓为平安幸福之意，一个坐落在江西中西部的县城，众所周知的景点武功山的南麓就在该县的西北部；安福是中国火腿之乡、中国竹子之乡、中国樟树之乡、陈山红心杉原产地、全国第一批商品粮基地县、全国首批生态文明建设典范城市,森林覆盖率为61%。回到我与她相遇的情节上来吧，我是经过我姐认识的她。有时候我在想人与人是不是有缘分谁也说不准，我在此之前从未和她有过交集，但是我们还是认识了。。。。。。 这是我第一次加她QQ见到的第一张照片。这是她15年国庆回家前在火车站火车室照的(其实是我猜的。。嘿嘿)。我们相遇的那天其实是有人早已“预谋”好的，那人想必也知道是我姐啦。本来我那个国庆是不打算回家，我的几个姐姐都说回来，叫我也回来，说什么“我爷爷病重了，你不回来看看爷爷吗”，所以我临时买了1号的车票，2号到家的。之后我姐说3号去逛街，我说好啊，我和我姐好久没去县城逛街了，于是3号那天我姐、我姐夫和我一起在县城的街上走着，突然旁边走来一位很靓丽的女孩，这女孩就是她。中午我们就在一家饭馆吃饭，吃饭的时候我就坐她旁边（我眼睛还偷偷往她身上瞟），是个男孩子都会这样的那天她的穿着是这样的，一套粉色的衣服，脚穿的是一双粉色的中跟鞋。之后我们互相留下了各自的联系方式，之后有了接下的一个又一个的故事。。。。回去后我们聊天，得知互相的感觉都很好，我们之间的感情也谈的很顺畅，犹如掉进了蜜罐，相互关心对方，在乎对方，这也是我第一次感受到爱情原来如此的甜美。 记得认识的那年11月底，她去厦门玩，我没时间陪她去，她跟我开玩笑说：“唉，以后我不想和你走的太近”。但是我当真了（当时我并不知道她在跟我开玩笑，因为我把我们之间的感情看得很重）。我还记得当时的聊天记录是这样的1234567她：“唉，以后我不想和你走的太近” “还想我了，都是骗人的” ：我她：“本来开始是想你，开始突然觉得坑爹了” “如果你对我没意思那就算了” ：我她：“那算了，就算了，888” “那你好好玩吧” : 我她：“谢谢你的好意” 这天我心情不好，感觉被她戏弄我的感情了，郁闷。。。。。。但是事情往往会往你的另一个方向发展。第二天上午她主动回我信息，她这样写道1她：“我没心情玩了” 我顿时我明白了她昨天说的那些都是假的，跟我开玩笑的，心情好了很多，因为她至少还会主动跟我聊。我们的聊天记录是这样的1234567891011121314151617181920她：“我没心情玩了” “怎么没心情玩了” ：我她：“因为你” “你不是说不想和我走的太近吗” ：我她：“你想气死我是吗？” “是你气我好吗，你以为我心情好吗” ：我她：“气的想吐血了” “那你以后就不要说那样的话，好吗” ：我她：“那你也不要气我啊！” “我什么时候气过你啊” ：我她：“那你的意思是怪我吗？” “如果你是真心对我有意思就不要在乎别人的看法，好吗？” ：我 “这跟怪谁没意思” ：我 “我只想听你一句你的真心话，你对我有没有想交往的想法” ：我她：“你都没有表态难道要我干嘛吗？”她：“我天天在和你聊天，你的意思就是我吃了没事干，是吗？” “我是认真的，我想和你交往下去” ：我她：“难道我不是吗？” “我也是这么想的，但是刚刚你说的那句话太让我失望了，我觉得有时候我自作多情” ：我她：“我快没疯了” 她：:sob: :sob: :sob: 她的这次旅行厦门算是确定我们都是认真的想谈场恋爱。我心里当时不知道有多开心，就像是蜜蜂采花粉时的喜悦。此时我们相识已经将近两个月了，我都不敢想我们之间的感情发展的那么顺利。她是那么认真（我能感觉到她是认真的）的跟我说：“我天天在和你聊天，你的意思就是我吃了没事干，是吗？”,我还记得当时她说这句话的语气（生气带着严肃）","tags":[{"name":"情感","slug":"情感","permalink":"ly2513.github.com/tags/情感/"}]},{"title":"Git bash 操作记住密码","date":"2016-04-14T13:45:33.000Z","path":"2016/04/14/Git-bash-操作记住密码/","text":"这篇博客主要介绍怎么解决在Windows系统下使用git Bush软件，每次提交代码时出现输入账号、密码问题，怎样记住提交者的账号和密码。git for windows （又名 msysgit）如何记住用户名和密码 第一步、创建存储用户名密码的文件 在home文件夹，一般是在 C:\\Documents and Settings\\Administrator下建立文件 .git-credentials （windows下不允许直接创建以.开头的文件，所以有一个小技巧：先创建一个文件名叫 ）git-credentials ,然后进入 git bash 使用命令：1mv git-credentials .git-credentials 用记事本、sublime等编辑器打开这文件输入，如果用户名中有 @，那么使用 % 代替：1https://&#123;username&#125;:&#123;password&#125;@github.com 比如：1https://zhangsan:123456@github.com 编辑完后保存 .git-credentials这个文件 第二步、添加config项 在任意文件夹下右键进入git bash然后输入：1git config --global credential.helper store 执行完后去查看 C:\\Documents and Settings\\Administrator\\.gitconfig 这个文件，发现最后多了一项：12[credential]helper = store 这样就成功了。然后要重开 git bash 窗口，再提交就不用输入用户名密码 – 此博客用于技术交流与传播，不用于商用，如需转载请注明出处，谢谢","tags":[{"name":"git","slug":"git","permalink":"ly2513.github.com/tags/git/"}]},{"title":"markdown使用教程","date":"2016-04-13T17:00:02.000Z","path":"2016/04/14/markdown使用教程/","text":"段落、标题、区域代码在你要表示的一级标题下面使用三个连续=以上的====字符而二级标题就是在其下面使用三个连续-以上的---字符1234一级标题=========二级标题---------- 效果如下： 一级标题二级标题 使用#号个数来表示html中对应标题大小如果想让标题在html中显示h1效果，你可以这样写：1# h1标题 效果如下： h1标题以此类推12345## h2标题 ### h3标题 #### h4标题##### h5标题###### h6标题 显示效果： h2标题h3标题h4标题h5标题h6标题无序列表markdown也可以编写html中的列表以下是几种无序列表的写法 以 -开头的无序列表123- 菜单1- 菜单2- 菜单3 显示效果： 菜单1 菜单2 菜单3 以*开头的无序列表1234* 部门1* 部门2* 部门3* 部门4 显示效果： 部门1 部门2 部门3 部门4 以`+开头的无序列表1234+ 员工甲+ 员工乙+ 员工丙+ 员工丁 显示效果： 员工甲 员工乙 员工丙 员工丁 问题来了，那对应html中有序列表了，markdown又是怎么写的了接下来就来感受下有序列表 有序列表1231. 攻城狮2. 产品狗3. 程序猿 显示效果： 攻城狮 产品狗 程序猿 对于html中加粗、斜体，markdown的写法如下 修辞和强调表示斜体：将要显示的文字用一对单个*包含1有志者事近成，三千越甲可吞吴，*苦心人天不负*，百二秦关终属楚. 显示效果： 有志者事近成，三千越甲可吞吴，苦心人天不负，百二秦关终属楚. 表示加粗：将要显示的文字用一对两个 ** 或者 一对两个__包含 123有志者事近成，三千越甲可吞吴，**苦心人天不负**，百二秦关终属楚.有志者事近成，三千越甲可吞吴，__苦心人天不负__，百二秦关终属楚. 显示效果： 有志者事近成，三千越甲可吞吴，苦心人天不负，百二秦关终属楚. 有志者事近成，三千越甲可吞吴，苦心人天不负，百二秦关终属楚. 链接markdown中链接的写法也比较简单，下面我们来看看到底怎么写的，见证奇迹的时候到了。。。123[链接的文字](链接的url &quot;这是链接title&quot;)[百度](www.baidu.com &quot;这是百度的链接，你信吗？&quot;) 显示效果： 百度 ##图片网页的中的图片那又是怎么表示了？会跟&lt;a&gt;链接一样吗？啥也别想了，我们看看不就知道啦123![图片的title](图片的url)![百度的logo,你说是吗？](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png ) 显示效果： 代码高亮显示123456function add()&#123; $a = 22; $b = 10; $c = $a * $b; return $c;&#125; &lt;code&gt;标签的代码块 function add(){ $a = 22; $b = 10; $c = $a * $b; return $c; } Use the add() function. &lt;pre&gt;标签的代码块function add(){ $a = 22; $b = 10; $c = $a * $b; return $c; } 问题标题1&gt; 问题1 显示效果： 问题1 绘制表格使用|、-、:符号绘制表格，通过:来控制对其方式12345| 项目 | 价格 | 数量 || --------- | --------: | :-------: || 计算机 | \\$1600 | 5 | | 手机 | \\$600 | 12 || 管线 | \\$16 | 234 | 效果如下 项目 价格 数量 计算机 \\$1600 5 手机 \\$600 12 管线 \\$16 234 以下是Markdown 的相关资料（待完善） Markdown 免费编辑器Windows 平台 MarkdownPad MarkPadLinux平台 ReTextMac平台 Mou在线编辑器 Markable.in Dillinger.io浏览器插件MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 – 此博客用于技术交流与传播，不用于商用，如需转载请注明出处，谢谢","tags":[{"name":"markdown","slug":"markdown","permalink":"ly2513.github.com/tags/markdown/"}]},{"title":"HEXO+Github,搭建属于自己的博客","date":"2016-03-25T05:23:00.000Z","path":"2016/03/25/HEXO-Github-搭建属于自己的博客/","text":"本文是基于mac OS x 系统上搭建hexo环境 hexo是一款基于Node.js的静态博客框架,hexo github链接,这篇教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。 之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用并不难，但是要做到简单通俗的让别人理解，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，不喜欢它们的页码样式。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。 ##配置环境 安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo： 1sudo npm install -g hexo 初始化然后，初始化hexo命令： 1hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 1hexo generate（hexo g也可以） 执行下面命令，可以启动本地服务，进行文章预览调试： 1hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好配置Github 建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 12# 假如你的github账号是zhangsan,那么仓库的名称就是 zhangsan.github.io 然后建立关联，我的blog在本地/usr/local/var/www/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： 1vim _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/leopardpan/leopardpan.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： 1hexo deploy 然后再浏览器中输入http://ly2513.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了 部署步骤 每次部署的步骤，可按以下三步来进行。 12345hexo cleanhexo generatehexo deploy 一些常用命令： 12345678910111213hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建pageName文件夹，在其文件夹下生产index.md文件hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 报错总结 ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法： 1npm install hexo-deployer-git --save 如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令： 1rm-rf.DS_Store ERROR Plugin load failed: hexo-server 原因：Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore. 解决方法，执行命令： 1sudo npm install hexo-server 执行命令hexo server，提示：Usage: hexo …. 原因：我认为是没有生成本地服务解决方法，执行命令： 1npm install hexo-server --save 提示：hexo-server@0.1.2 node_modules/hexo-server 表示成功了 这个时候再执行： 1hexo-server 得到：INFOHexois running at http://localhost:4000/,按 Ctrl+C进行撤销 这个时候再点击http://localhost:4000,正常情况下应该是最原始的画面，但是我看到的是： 白板和Cannot GET / 几个字 原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： 12345npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： 1hexo generate（或hexo g） 启动本地服务器： 1hexo server（或hexo s） 再点击网址http://localhost:4000终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。主题推荐 这里有大量的主题列表使用方法里面 都有详细的介绍，我就不多说了。 我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，😄 Cover- A chic theme with facebook-like cover photo Oishi- A white theme based on Landscape plus and Writing. Sidebar- Another theme based on Light with a simple sidebar TKL- A responsive design theme for Hexo. 一个设计优雅的响应式主题 Tinnypp- A clean, simple theme based on Tinny Writing- A small and simple hexo theme based on Light Yilia- Responsive and simple style 优雅简洁响应式主题，我用得就是这个。 Pacman voidy- A theme with dynamic tagcloud and dynamic snow 一些基本目录文章在source/_posts, 文章支持Markdown语法，可以使用一些MarkDown渲染工具。如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接，之类的都在这里。开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。修改头像 我当前的路径/usr/local/var/www/blog/themes/yilia，ls 你可以看到 Gruntfile.js _config.yml package.json README.md layout source vim _config.yml 进去，找到 #你的头像url avatar: 后接一个URL就行了，头像就修改成功了 修改主题和作者名字 我当前的路径/usr/local/var/www/blog，执行ls命令 你可以看到 123_config.yml node_modules public source themesdb.json package.json scaffolds ssh-keygen vim _config.yml 进去，找到 author: 李勇，修改成你自己的名字就行了 修改主题，然后继续往下找到 扩展Plugins: http://hexo.io/plugins/Themes: http://hexo.io/themes/进入到/usr/local/var/www/blog/_config.yml中找到 theme:theme:后面接你自己的主题名字就行了,然后分别执行 部署 hexo g 提交 hexo d 你的主题，和名字就修改成功了","tags":[{"name":"gitbub","slug":"gitbub","permalink":"ly2513.github.com/tags/gitbub/"},{"name":"hexo","slug":"hexo","permalink":"ly2513.github.com/tags/hexo/"}]}]